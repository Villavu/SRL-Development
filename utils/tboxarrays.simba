{$DEFINE SRL_TBOXARRAY_INCLUDED}
{$IFNDEF SRL_UTILS}
  {$I SRL/utils.simba}
{$ENDIF}

(*
TBoxArray
=========
TBoxArray related methods
*)

function TBoxArray.Combine(Other: TBoxArray): TBoxArray; 
begin
  Result.SetLength(Self.Length() + Other.Length());
  if self.Length() > 0 then
    MemMove(self[0], result[0], self.Length()*SizeOf(self[0]));
  if Other.Length() > 0 then
    MemMove(Other[0], result[Self.Length()], Other.Length()*SizeOf(Other[0]));
end;

function TBoxArray.Equals(Other:TBoxArray): Boolean; 
begin
  if (Self.Length() <> Other.Length()) then Exit(False);
  if (Self.Length() = 0) then Exit(True);
  Result := CompareMem(Self[0], Other[0], self.Length()*SizeOf(self[0]));
end;

procedure TBoxArray.SortFromMidPoint(From: TPoint);
var
  I, L: Integer;
  Mid: TPoint;
  weights: TIntegerArray;
begin
  L := Self.High();
  if (L <= 0) then
    Exit;

  weights.SetLength(L + 1);
  for i := 0 To L do
  begin
    Mid := MiddleBox(Self[i]);
    weights[i] := Round(Sqr(From.X - Mid.X) + Sqr(From.Y - Mid.Y));
  end;

  Self.Sort(weights, True);
end;

procedure TBoxArray.ModifySide(side:String='x1'; change:Int32=1);
var i:Int32;
begin
  side := LowerCase(side);
  if side.Length() < 2 then Exit();
  side.SetLength(2);
  for i:=0 to self.High() do
    case Side of
      'x1': self[i].x1 += change;
      'y1': self[i].y1 += change;
      'x2': self[i].x2 += change;
      'y2': self[i].y2 += change;
    end;
end;

function TBoxArray.Offset(pt:TPoint): TBoxArray;
var i:Int32;
begin
  Result.SetLength(Self.Length());
  
  for i:=0 to self.High() do
  begin
    Result[i].X1 := Self[I].X1 + pt.x;
    Result[i].Y1 := Self[I].Y1 + pt.y;
    Result[i].X2 := Self[I].X2 + pt.x;
    Result[i].Y2 := Self[I].Y2 + pt.y;
  end;
end;

function TBoxArray.Merge(): TBox; 
var i:Int32;
begin
  if Self.Length() = 0 then
    Exit;

  Result := Self[0];
  for i:=1 to self.High() do
    Result := Result + Self[i];
end;

procedure TBoxArray.SortByX(LowToHi: Boolean = True);
var
  Weights: TIntegerArray;
  I: Int32;
begin
  if Self.Length() = 0 then
    Exit;

  Weights.SetLength(Self.Length());
  for I := 0 to Weights.High() do
    Weights[I] := Self[I].X1;

  Self.Sort(Weights, LowToHi);
end;

procedure TBoxArray.SortByY(LowToHi: Boolean = True);
var
  Weights: TIntegerArray;
  I: Int32;
begin
  if Self.Length() = 0 then
    Exit;

  Weights.SetLength(Self.Length());
  for I := 0 to Weights.High() do
    Weights[I] := Self[I].Y1;

  Self.Sort(Weights, LowToHi);
end;

// Sorts column wise
// Example: [0][1][2][3]
//          [4][5][6]
procedure TBoxArray.SortByXY(Tolerance: Int32 = 0);
var
  I, J: Int32;
  Weights: TIntegerArray;
  Means: TPointArray;
begin
  if Self.Length() = 0 then
    Exit;
  
  Weights.SetLength(Self.Length());
  Means.SetLength(Self.Length());
  for I := 0 to Self.High() do
    Means[I] := Self[I].Middle();

  for I := 0 to Self.High() do
  begin
    Weights[I] := Means[I].X + (Means[I].Y * 1000);
    if Tolerance = 0 then
      Continue;
      
    for J := 0 to Self.High() do
      if Abs(Means[I].Y - Means[J].Y) < Tolerance then
        Weights[I] := Means[I].X + (Means[J].Y * 1000);
  end;
    
  Self.Sort(Weights, True);
end;

function TBoxArray.Middles: TPointArray; 
var
  I: Int32;
begin
  Result.SetLength(Self.Length);
  for I := 0 to Self.High() do
    Result[I] := Self[I].Middle();
end;

function Grid(Columns, Rows, Width, Height: Int32; Spacing, Start: TPoint): TBoxArray;
var
  I: Int32;
begin
  Start.X += (Width div 2);
  Start.Y += (Height div 2);

  Spacing.X += Width;
  Spacing.Y += Height;

  Result.SetLength(Columns * Rows);

  for I := 0 to Result.High() do
  begin
    Result[I].X1 := Start.X + I mod Columns * Spacing.X - Width div 2;
    Result[I].Y1 := Start.Y + I div Columns * Spacing.Y - Height div 2;
    Result[I].X2 := Result[I].X1 + Width;
    Result[I].Y2 := Result[I].Y1 + Height;
  end;
end;
