(*
MainScreen
==========
*)

{$DEFINE SRL_MAINSCREEN_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

{.$DEFINE SRL_DEBUG_MOUSE} // Enable me print uptext recognition


(*
type TRSObjectFinder
~~~~~~~~~~~~~~~~~~~~

TRSObjectFinder is the record used in **MainScreen.FindObject**.

* **TRSObjectFinder.Zoom**

  When designing a object finder you **must** be at **default zoom(50)** in the **fixed** client mode.
  This allows SRL to convert the finder to work at any zoom and client mode once made.

  .. figure:: ../../images/zoom.png

    A finder working at different zoom levels producing similar results.

* **TRSObjectFinder.Colors**

  An color array which will searched for. Use ACA to acquire color(s).

  .. pascal::

    Finder.Colors += CTS2(2503237, 20, 0.10, 0.14); // brown
    Finder.Colors += CTS2(5526875, 15, 0.19, 0.06); // grey

  .. figure:: ../../images/color_array.png

    The two colors above found and merged together.

* **TRSObjectFinder.ColorClusters**

  An array of "color clusters" which will be merged together. Use ACA to acquire color(s).

  A "color cluster" consists of a `primary` and `secondary` color and a `distance` value.
  When searched for only `primary` colors within `distance` of `secondary` colors are returned.

  .. pascal::

    Finder.ColorClusters += [
      CTS2(2503237, 20, 0.10, 0.14), // brown
      CTS2(5526875, 15, 0.19, 0.06), // grey
      2                              // distance
    ];

  .. figure:: ../../images/color_cluster.png

    The above color cluster found where "brown" is within 2 pixels of "grey".

* **TRSObjectFinder.Erode**

  The amount to erode before clustering. This is useful for removing small amounts of noise.

  .. pascal::

     Finder.Erode := 2;

  .. figure:: ../../images/erode.png

    Erode before and after.

* **TRSObjectFinder.Grow**

  The amount to grow **before** eroding. This is useful for filling gaps.

  .. pascal::

     Finder.Grow := 2;

  .. figure:: ../../images/grow.png

    Grow before and after.

  Grow can also be paired with erode which is quite powerful.

  .. pascal::

   Finder.Grow := 3;
   Finder.Erode := 4;

  .. figure:: ../../images/grow_erode.png

    Grow paired with Erode.

* **TRSObjectFinder.ClusterDistance**

  The distance to pass to *ClusterTPA*, this is how multiple objects are grouped up. `Distance=5` would mean that points that are closer than or equal to 5 pixels away are considered close enough to merge into a singular group.

  .. pascal::

     Finder.ClusterDistance := 5;

  .. figure:: ../../images/cluster_5.png

    Cluster distance **5** produces four individual chairs

  .. pascal::

     Finder.ClusterDistance := 20;

  .. figure:: ../../images/cluster_20.png

    Cluster distance **20** produces two sets of chairs

*  **TRSObjectFinder.MinLongSide, TRSObjectFinder.MaxLongSide, TRSObjectFinder.MinShortSide, TRSObjectFinder.MaxShortSide**

  Any match that exceeds these values will be removed.
  The bounding rectangle is used which has a **long** and a **short** side measured in pixels.

  .. pascal::

    // Removes matches where the short side isn't within 10 and 20 pixels
    Finder.MinShortSide := 10;
    Finder.MaxShortSide := 20;
    // Removes matches where the long side isn't within 20 and 40 pixels
    Finder.MinLongSide := 20;
    Finder.MaxLongSide := 40;

  .. figure:: ../../images/bounding_rect.png

    Example bounding rectangle with a long and short side.
*)
type
  TRSObjectFinder = record
    Colors: array of TCTS2Color;
    ColorClusters: array of record Primary, Secondary: TCTS2Color; Distance: Int32;end;
    ClusterDistance: Int32;
    Erode: Int32;
    Grow: Int32;
    MinLongSide, MaxLongSide: Int32;
    MinShortSide, MaxShortSide: Int32;
  end;

  TRSMainScreen = record(TRSInterface)
    UpTextArea: array[ERSClientMode] of TBox;
    UpTextFilter: TOCRFilter;
  end;

procedure TRSMainScreen.Setup(Name: String); override;
begin
  inherited;

  with Self.BoundsFinder.Alignments[ERSClientMode.FIXED] do
  begin
    Left   := [@RootInterface.X1, 4];
    Right  := [@RootInterface.X1, 515];
    Top    := [@RootInterface.Y1, 4];
    Bottom := [@RootInterface.Y1, 337];
  end;

  with Self.BoundsFinder.Alignments[ERSClientMode.RESIZABLE_CLASSIC] do
  begin
    Left   := [@RootInterface.X1];
    Right  := [@RootInterface.X2];
    Top    := [@RootInterface.Y1];
    Bottom := [@RootInterface.Y2];
  end;

  // Same as above
  with Self.BoundsFinder.Alignments[ERSClientMode.RESIZABLE_MODERN] do
  begin
    Left   := [@RootInterface.X1];
    Right  := [@RootInterface.X2];
    Top    := [@RootInterface.Y1];
    Bottom := [@RootInterface.Y2];
  end;

  Self.UpTextArea[ERSClientMode.RESIZABLE_CLASSIC] := [3, 3, 500, 21];
  Self.UpTextArea[ERSClientMode.RESIZABLE_MODERN]  := [3, 3, 500, 21];
  Self.UpTextArea[ERSClientMode.FIXED] := [7, 7, 500, 25];

  Self.UpTextFilter := TOCRUpTextFilter.Create(85, 60);
  Self.UpTextFilter.MinCharacterMatch := '-';
end;

(*
MainScreen.GetUpText
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.GetUpText: String;

Returns the current uptext.
Uptext is the top left which appears when moving the mouse over a object.

Example
-------

  WriteLn(MainScreen.GetUpText());
*)
function TRSMainScreen.GetUpText: String;
begin
  Result := OCR.RecognizeUpText(Self.UpTextArea[RSClient.ClientMode], Self.UpTextFilter, RS_FONT_BOLD_12_SHADOW);

  {$IFDEF SRL_DEBUG_UPTEXT}
  Self.DebugLn('UpText: ' + Result);
  {$ENDIF}
end;

(*
MainScreen.IsUpText
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.IsUpText(Text: TStringArray; Timeout: Int32 = -1): Boolean;

Returns true if the uptext is found **anywhere** in either of the **Text** strings.

Example
-------

  WriteLn(MainScreen.MainScreen.IsUpText(['Chicken', 'Wolf']));
*)
function TRSMainScreen.IsUpText(Text: TStringArray; Timeout: Int32 = -1): Boolean; overload;

  function IsUpText: Boolean;
  var
    I: Int32;
    UpText: String;
  begin
    UpText := Self.GetUpText();

    for I := 0 to High(Text) do
      if (Text[I] in UpText) or (Text[I] = UpText) then
        Exit(True);
  end;

var
  T: UInt64;
begin
  if (Timeout = -1) then
    T := GetTickCount() + Round(SRL.SkewedRand(100, 85, 250))
  else
    T := GetTickCount() + Timeout;

  repeat
    if IsUpText() then
    begin
      Wait(50); // Uptext is delayed at least a frame. wait 50ms for confirmation.
      if IsUpText() then
        Exit(True);
    end;

    Wait(25);
  until (GetTickCount() >= T);
end;

(*
MainScreen.IsUpText
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.IsUpText(Text: String; Timeout: Int32 = -1): Boolean;

Overloaded function that accepts a string rather than a TStringArray.

Example
-------

  WriteLn(MainScreen.IsUpText('Chicken'));
*)
function TRSMainScreen.IsUpText(Text: String; Timeout: Int32 = -1): Boolean; overload;
begin
  Result := Self.IsUpText([Text], Timeout);
end;

(*
MainScreen.SetHighestPitch
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TRSMainScreen.SetHighestPitch;

Moves the camera to the highest pitch.
There is no way to detect the camera pitch reliably using color, this is why SRL only provides this method.

Example
-------

  MainScreen.SetHighestPitch();
*)
procedure TRSMainScreen.SetHighestPitch;
begin
  Keyboard.KeyDown(VK_UP);

  try
    for 1 to 10 do // 2500ms timeout
      if (SRL.GetPixelShift(Self.Bounds(), 250) / Self.Bounds.Area() * 100) < 10 then // less than 10% of the screen changed in 250ms
        Break;
  finally
    Keyboard.KeyUp(VK_UP);
  end;
end;

(*
MainScreen.ConvertDistance
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.ConvertDistance(Dist: Int32; Accuracy: Single = 1.05): Int32;

Converts a distance acquired from the **fixed client** and **default zoom(50)** to the
current mainscreen.

Example
-------

  // 20 pixels on the fixed client and default zoom(50) is currently x pixels on the mainscreen.
  WriteLn(MainScreen.TranslateDistance(20));
*)
function TRSMainScreen.ConvertDistance(Dist: Int32; Accuracy: Single = 1.05): Int32;
begin
  // Implemented in minimaptoms.simba
end;

(*
MainScreen.GetPlayerBox
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.GetPlayerBox: TBox;

Returns a box surrounding our player. Works at any zoom level.
*)
function TRSMainScreen.GetPlayerBox: TBox;
begin
  // Implemented in minimaptoms.simba
end;

(*
MainScreen.FacePoint
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.FacePoint(P: TPoint; Randomness: Int32 = 0): Boolean;

Rotates the camera to face point `P`.
*)
function TRSMainScreen.FacePoint(P: TPoint; Randomness: Int32 = 0): Boolean;
begin
  // Implemented in minimaptoms.simba
end;

(*
Mainscreen.PointToMM
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.PointToMM(MS: TPoint; Height: Int32 = 0; Accuracy:Double = 0.2): Vector3;

Takes a mainscreen point and converts it to a point on the minimap.

Returns a Vector3 which includes input height. Conversion to a TPoint if that's what you need is simply
done by calling `.ToPoint` on the result.

Example
-------

  WriteLn Mainscreen.PointToMM(Point(250,140), 2);           // as a vector (more accurate)
  WriteLn Mainscreen.PointToMM(Point(250,140), 2).ToPoint(); // as a TPoint (lost accuracy)
*)
function TRSMainScreen.PointToMM(MS: TPoint; Height: Int32 = 0; Accuracy:Double = 0.2): Vector3;
begin
  // Implemented in minimaptoms.simba
end;

(*
Mainscreen.FindObject
~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.FindObject(Finder: TRSObjectFinder; Area: TBox): T2DPointArray;

Returns all matches of an TRSObjectFinder in the desired area.

See the top of this page page for documentation about the TRSObjectFinder record.

Example
-------

  var MyFinder: TRSObjectFinder;

  // Some chairs in varrock west bank
  MyFinder.Colors += CTS2(1328725, 6, 0.06, 0.69);
  MyFinder.ClusterDistance := 5;
  MyFinder.Erode := 2;
  MyFinder.MinLongSide := 10;
  MyFinder.MaxLongSide := 15;

  Debug(MainScreen.FindObject(MyFinder, MainScreen.Bounds()));
*)
function TRSMainScreen.FindObject(Finder: TRSObjectFinder; Area: TBox): T2DPointArray; overload;
var
  TPA, Primary, Secondary: TPointArray;
  ATPA: T2DPointArray;
  I: Int32;
  L, S: Int32;
  R: TRectangle;
begin
  if Finder = [] then
    Self.Fatal('Empty TRSObjectFinder passed');

  Area.Clip(Self.Bounds());

  // Translate distances
  Finder.ClusterDistance := Self.ConvertDistance(Finder.ClusterDistance);
  Finder.Erode := Self.ConvertDistance(Finder.Erode);
  Finder.Grow := Self.ConvertDistance(Finder.Grow);

  Finder.ColorClusters := Copy(Finder.ColorClusters); // Make a copy!
  for I := 0 to High(Finder.ColorClusters) do
    Finder.ColorClusters[I].Distance := Self.ConvertDistance(Finder.ColorClusters[I].Distance);

  Finder.MinLongSide  := Self.ConvertDistance(Finder.MinLongSide);
  Finder.MaxLongSide  := Self.ConvertDistance(Finder.MaxLongSide);
  Finder.MinShortSide := Self.ConvertDistance(Finder.MinShortSide);
  Finder.MaxShortSide := Self.ConvertDistance(Finder.MaxShortSide);

  if (Finder.MaxLongSide = 0) then
    Finder.MaxLongSide := $FFFFFF;
  if (Finder.MaxShortSide = 0) then
    Finder.MaxShortSide := $FFFFFF;

  // Find colors
  for I := 0 to High(Finder.Colors) do
    if SRL.FindColors(TPA, Finder.Colors[I], Area) > 0 then
      ATPA += TPA;

  // Find color clusters
  for I := 0 to High(Finder.ColorClusters) do
    if (SRL.FindColors(Primary, Finder.ColorClusters[I].Primary, Area) > 0) and
       (SRL.FindColors(Secondary, Finder.ColorClusters[I].Secondary, Area) > 0) then
    begin
      TPA := Primary.PointsInRangeOf(Secondary, 0, Finder.ColorClusters[I].Distance);

      if TPA <> [] then
        ATPA += TPA;
    end;

  TPA := ATPA.Merge();

  // Process TPA
  if (Length(TPA) > 0) then
  begin
    if (Finder.Grow > 0) then
      TPA := TPA.Grow(Finder.Grow);
    if (Finder.Erode > 0) then
      TPA := TPA.Erode(Finder.Erode);

    if Length(TPA) > 0 then
    begin
      ATPA := TPA.Cluster(Finder.ClusterDistance);

      if (Finder.MinShortSide > 0) or (Finder.MaxShortSide > 0) or (Finder.MinLongSide > 0) or (Finder.MaxLongSide > 0) then
      begin
        for I := 0 to High(ATPA) do
        begin
          R := ATPA[I].Edges().MinAreaRect();

          if ((Finder.MinShortSide > 0) or (Finder.MaxShortSide > 0)) and (not InRange(R.ShortSideLen, Finder.MinShortSide, Finder.MaxShortSide)) then
            Continue;
          if ((Finder.MinLongSide > 0) or (Finder.MaxLongSide > 0)) and (not InRange(R.LongSideLen, Finder.MinLongSide, Finder.MaxLongSide)) then
            Continue;

          Result += ATPA[I];
        end;
      end else
        Result := ATPA;
    end;

    Result.SortBySize();
  end;
end;

(*
Mainscreen.FindObject
~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.FindObject(Finder: TRSObjectFinder): T2DPointArray;

Overload which searches the entire MainScreen.

Example
-------

  Debug(MainScreen.FindObject(MyFinder));
*)
function TRSMainScreen.FindObject(Finder: TRSObjectFinder): T2DPointArray; overload;
begin
  Result := Self.FindObject(Finder, Self.Bounds());
end;

(*
Mainscreen.IsVisible
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.IsVisible(P: TPoint): Boolean;

Returns true if the TPoint is visible (not hidden by any other interfaces)
on the mainscreen.

This is only useful in resizable mode. The interfaces checked are Chatbox, Minimap and Gametabs.

Example
-------

  if MainScreen.IsVisible([100, 100]) then
    WriteLn('The point is not behind Chatbox, Minimap or Gametabs.');
*)
function TRSMainScreen.IsVisible(P: TPoint): Boolean;
begin
  Result := Self.Bounds.Contains(P);

  if Result then
  begin
    if Chat.IsOpen() and Chat.Bounds().Contains(P) then
      Exit(False);
    if ChatButtons.Bounds().Contains(P) then
      Exit(False);
    if Minimap.Bounds.Expand(50).Contains(P) then
      Exit(False);
    if GameTabs.Bounds().Contains(P) then
      Exit(False);
  end;
end;

(*
type TRSHitsplat
~~~~~~~~~~~~~~~~
.. pascal::
  type
    TRSHitsplat = record
      Position: TPoint;  // Middle of the found hitsplat
      Hit: Int32;        // Hit amount
      Red: Boolean;      // True if red, false if blue.
    end;
*)
type
  TRSHitsplat = record
    Position: TPoint;
    Hit: Int32;
    Red: Boolean;
  end;

  TRSHitsplatArray = array of TRSHitsplat;

(*
Mainscreen.FindHitsplats
~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.FindHitsplats(Area: TBox): TRSHitsplatArray;

Finds hitsplats in the desired area. Returns an array of TRSHitsplat.

Example
-------

  var Splats: TRSHitsplatArray;
  var I: Int32;

  Splats := MainScreen.FindHitsplats(MainScreen.Bounds());
  for I := 0 to High(Splats) do
    WriteLn(Splats[I].Position);
*)
function TRSMainScreen.FindHitsplats(Area: TBox): TRSHitsplatArray;

  function Find(Color: Int32; Red: Boolean): TRSHitsplatArray;
  var
    TPA: TPointArray;
    B: TBox;
    Text: String;
    Hit: Int32;
  begin
    if SRL.FindColors(TPA, CTS0(Color), Area) = 0 then
      Exit;

    for B in TPA.Cluster(3).Bounds() do
      if (B.Width >= 10) and (B.Height >= 10) then
      begin
        Hit := OCR.RecognizeNumber(B.Expand(5, Area), TOCRColorFilter.Create([$FFFFFF]), RS_FONT_PLAIN_11);
        
        Result += [B.Middle(), Hit, Red];
      end;
  end;

begin
  Result := Find($0000C0, True) + Find($FF4040, False); // red, blue
end;

(*
Mainscreen.FindHitsplats
~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.FindHitsplats(Area: TBox): TRSHitsplatArray;

Overload which finds hitsplats on the entire mainscreen.
*)
function TRSMainScreen.FindHitsplats: TRSHitsplatArray; overload;
begin
  Result := Self.FindHitsplats(Self.Bounds());
end;

(*
type TRSHitsplat
~~~~~~~~~~~~~~~~
.. pascal::
  type
    TRSHPBar = record
      Bounds: TBox;       // Bounds of the bar
      Percent: Single;  // Green percent of the bar.
    end;
*)
type
  TRSHPBar = record
    Bounds: TBox;
    Percent: Single;
  end;

  TRSHPBarArray = array of TRSHPBar;

(*
Mainscreen.FindHPBars
~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.FindHPBars: TRSHPBarArray;

Finds hitpoints bars in the desired area. Returns an array of TRSHPBar.

Example
-------

  var Bars: TRSHPBarArray;
  var I: Int32;

  Bars := MainScreen.FindHPBars(MainScreen.Bounds());
  for I := 0 to High(Bars) do
    WriteLn(Bars[I].Percent, ' @ ', Bars[I].Bounds);
*)
function TRSMainScreen.FindHPBars(Area: TBox): TRSHPBarArray; overload;
const
  COLOR_BARS = [
  {GREEN} $00FF00,
  {RED} $0000FF
  ];
  COLOR_SPLATS = [
  {BLUE} $FF4040, $AD0703, $550503,
  {RED} $0000C0, $03037F, $010161,
  {BLACK AND WHITE} $FFFFFF, $000000,
  {TINTED RED} $000046, $01012F, $010124,
  {TINTED BLUE} $5E1717, $400301, $1F0201
  ];
const
  BAR_WIDTH = 29;
  BAR_HEIGHT = 4;
var
  Matrix: TIntegerMatrix;

  function FindColors(Bitmap: TMufasaBitmap; Colors: TIntegerArray): TPointArray;
  var
    Color: Integer;
    TPA: TPointArray;
  begin
    for Color in Colors do
      if Bitmap.FindColors(TPA, Color) then
        Result += TPA;
  end;

  procedure Clean(TPA: TPointArray);
  var
    I: Integer;
  begin
    TPA.SortByX();

    for I := 0 to High(TPA) do
      with TPA[I] do
      begin
        if (Matrix[Y][X - 1] <> 0) then
          Matrix[Y][X] := 255;
      end;

    for I := High(TPA) downto 0 do
      with TPA[I] do
      begin
        if (Matrix[Y][X + 1] <> 0) then
          Matrix[Y][X] := 255;
      end;
  end;

  function CheckBar(StartX, StartY: Integer): Boolean;
  var
    X, Y: Integer;
  begin
    for Y := StartY to StartY + BAR_HEIGHT do
      for X := StartX to StartX + BAR_WIDTH - 3 do // allow bar width -3 as a match.
        if (Matrix[Y, X] <> 255) then
          Exit;

    Result := True;
  end;

  function Find: TBoxArray;
  var
    W, H, X, Y: Integer;
  begin
    W := Matrix.Width;
    H := Matrix.Height;

    while (Y < H) do
    begin
      X := 0;
      while (X < W) do
      begin
        if CheckBar(X, Y) then
        begin
          Result += [X, Y, X + BAR_WIDTH, Y + BAR_HEIGHT];

          // skip next three rows
          Inc(Y,2);
          Break;
        end;

        Inc(X);
      end;

      Inc(Y);
    end;
  end;

var
  B, Bar: TBox;
  Percent: Single;
  TPA: TPointArray;
  Bitmap, Sub: TMufasaBitmap;
begin
  Area.Clip(Self.Bounds);
  if (Area.Width < BAR_WIDTH) or (Area.Height < BAR_HEIGHT) then
    Exit;

  Bitmap.Init();
  Bitmap.LoadFromClient(Self.Bounds);

  TPA := FindColors(Bitmap, COLOR_BARS);

  for TPA in TPA.Cluster(15) do
  begin
    B := GetTPABounds(TPA);

    TPA := TPA.Offset(-B.X1 + 1, -B.Y1 + 1);

    Matrix.SetSize(B.Width + 2, B.Height + 2);
    Matrix.Fill(0);
    Matrix.SetValues(TPA, 255);

    Sub := Bitmap.Copy(B.X1, B.Y1, B.X2, B.Y2);
    TPA := FindColors(Sub, COLOR_SPLATS);
    TPA := TPA.Offset(1, 1);
    Sub.Free();

    Clean(TPA);

    for Bar in Find() do
    begin
      Bar := Bar.Offset(B.X1 - 1, B.Y1 - 1);

      Sub := Bitmap.Copy(Bar.X1, Bar.Y1, Bar.X2, Bar.Y2);
      if Sub.FindColors(TPA, $00FF00) then
        Percent := (TPA.Bounds.Width()) / 30 * 100
      else
        Percent := 0;
      Sub.Free();

      Result += [Bar, Percent];
    end;
  end;

  Bitmap.Free();
end;

(*
Mainscreen.FindHPBars
~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.FindHPBars: TRSHPBarArray;

Overload which finds hp bars on the entire mainscreen.
*)
function TRSMainScreen.FindHPBars: TRSHPBarArray; overload;
begin
  Result := Self.FindHPBars(Self.Bounds());
end;

(*
Mainscreen.DidRedClick
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.DidRedClick: Boolean;

Returns true if a red click happened at the current mouse position.

Example
-------

  Mouse.Move(100, 100);
  Mouse.Click(MOUSE_LEFT);
  if MainScreen.DidRedClick() then
    WriteLn('Red click!');
*)
function TRSMainScreen.DidRedClick(WaitTime: Integer = 150): Boolean;
var
  Bitmap: TMufasaBitmap;
  Area: TBox;
  TPA: TPointArray;
  T: UInt64;
begin
  Area := TBox.Create(Mouse.Position(), 20, 20);
  Area.Clip(Self.Bounds);

  if (Area.Width > 5) and (Area.Height > 5) then
  begin
    Bitmap.Init();

    T := GetTickCount() + SRL.TruncatedGauss(WaitTime, WaitTime * 2);
    while (T > GetTickCount()) and (not Result) do
    begin
      Bitmap.LoadFromClient(Area);

      if Bitmap.FindColorsTolerance(TPA, 255, 10) and (Length(TPA) >= 30) and
         Bitmap.FindColorsTolerance(TPA, 65536, 10) and (Length(TPA) >= 30) then
      begin
        Result := True;
        Break;
      end;

      Wait(25, 100, wdLeft);
    end;

    Bitmap.Free();
  end;
end;

(*
Mainscreen.DidYellowClick
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.DidYellowClick: Boolean;

Returns true if a yellow click happened at the current mouse position.

Example
-------

  Mouse.Move(100, 100);
  Mouse.Click(MOUSE_LEFT);
  if MainScreen.DidYellowClick() then
    WriteLn('Yellow click!');
*)
function TRSMainScreen.DidYellowClick(WaitTime: Integer = 150): Boolean;
var
  Bitmap: TMufasaBitmap;
  Area: TBox;
  TPA: TPointArray;
  T: UInt64;
begin
  Area := TBox.Create(Mouse.Position(), 20, 20);
  Area.Clip(Self.Bounds);

  if (Area.Width > 5) and (Area.Height > 5) then
  begin
    Bitmap.Init();

    T := GetTickCount() + SRL.TruncatedGauss(WaitTime, WaitTime * 2);
    while (T > GetTickCount()) do
    begin
      Bitmap.LoadFromClient(Area);

      if Bitmap.FindColorsTolerance(TPA, 65535, 10) and (Length(TPA) >= 30) and
         Bitmap.FindColorsTolerance(TPA, 65536, 10) and (Length(TPA) >= 30) then
      begin
        Result := True;
        Break;
      end;

      Wait(25, 100, wdLeft);
    end;

    Bitmap.Free();
  end;
end;

procedure TRSMainScreen.Draw(Bitmap: TMufasaBitmap); override;
var
  Splat: TRSHitsplat;
  Bar: TRSHPBar;
begin
  inherited;

  for Splat in Self.FindHitsplats() do
    Bitmap.DrawCircle(Splat.Position, 10, $00FF00);
  for Bar in Self.FindHPBars() do
    Bitmap.DrawBox(Bar.Bounds, $00FFFF);
end;

var
  MainScreen: TRSMainScreen;

begin
  MainScreen.Setup('MainScreen');
end;

