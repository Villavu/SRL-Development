{$DEFINE SRL_MINIMAP_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

type
  ERSMinimapDot = (
    PLAYER, 
    NPC, 
    ITEM
  );
  ERSMinimapDots = set of ERSMinimapDot;

type
  TRSMinimap = record(TRSInterface)
    CompassCircleOffset: TPoint;
    XPCircleOffset: TPoint;
    HitpointsCircleOffset: TPoint;
    PrayerCircleOffset: TPoint;
    RunCircleOffset: TPoint;
    SpecAttackCircleOffset: TPoint;
    PolygonOffset: TPointArray;
    FlagBitmap: Int32;
  end;

function TRSMinimap.GetCompassCircle: TCircle;
begin
  Result := [Self.X1 + Self.CompassCircleOffset.X, Self.Y1 + Self.CompassCircleOffset.Y, 17];
end;

function TRSMinimap.GetXPCircle: TCircle;
begin
  Result := [Self.X1 + Self.XPCircleOffset.X + 10, Self.Y1 + Self.XPCircleOffset.Y, 11];
end;

function TRSMinimap.GetHPCircle: TCircle;
begin
  Result := [Self.X1 + Self.HitpointsCircleOffset.X, Self.Y1 + Self.HitpointsCircleOffset.Y, 12];
end;

function TRSMinimap.GetPrayerCircle: TCircle;
begin
  Result := [Self.X1 + Self.PrayerCircleOffset.X, Self.Y1 + Self.PrayerCircleOffset.Y, 12];
end;

function TRSMinimap.GetRunCircle: TCircle;
begin
  Result := [Self.X1 + Self.RunCircleOffset.X, Self.Y1 + Self.RunCircleOffset.Y, 12];
end;

function TRSMinimap.GetSpecAttackCircle: TCircle;
begin
  Result := [Self.X1 + Self.SpecAttackCircleOffset.X, Self.Y1 + Self.SpecAttackCircleOffset.Y, 12];
end;

function TRSMinimap.GetOrbLevel(Orb: TCircle): Int32;
begin
  Result := OCR.RecognizeNumber([Orb.X-35, Orb.Y-1, Orb.X-15, Orb.Y+9], TOCRShadowFilter.Create(), RS_FONT_PLAIN_11);
end;

function TRSMinimap.GetRunEnergy: Int32;
begin
  Result := Self.GetOrbLevel(GetRunCircle());
end;

function TRSMinimap.GetPolygon: TPointArray;
begin
  Result := Self.PolygonOffset.Offset(Self.Center);
end;

function TRSMinimap.GetCompassAngle(AsDegrees: Boolean = True): Double;
var
  dotpts: TPointArray;
  g: T2DPointArray;
begin
  with Self.GetCompassCircle do
  begin
    if SRL.FindColors(dotpts, CTS1(2565532, 50), Bounds()) then // red
    begin
      FilterPointsDist(dotpts, 12, Radius, X,Y);
      g := dotpts.Cluster(4);

      if (g[0].Mean().DistanceTo(g[1].Mean()) > 25) then Swap(g[0], g[2]);
      if (g[0].Mean().DistanceTo(g[2].Mean()) > 25) then Swap(g[0], g[1]);

      if Abs(srl.DeltaAngle(ArcTan2(g[1][0].Y - Y, g[1][0].X - X)+PI/2, ArcTan2(g[0][0].Y - Y, g[0][0].X - X), 2*PI)) > PI/2 then
        Swap(g[1], g[2]);

      Result := FixRad(ArcTan2(g[1].MeanEx().Y - g[2].MeanEx().Y, g[1].MeanEx().X - g[2].MeanEx().X));

      if AsDegrees then Result := Degrees(Result);
    end;
  end;
end;


procedure TRSMinimap.SetCompassAngle(Degrees: Double; Accuracy: Double = 5);
const
  DEG_PER_PIXEL = 2.83;
var
  Available: TBox;
  Remaining: Int32;
  LeftToRight: Boolean;
  Destination: TPoint;
  MousePosition: TPoint;
  Pixels: Int32;
  T: UInt64;
  CustomMouse: TMouse;
begin
  CustomMouse := Mouse;
  CustomMouse.MissChance := 0;
  CustomMouse.IdleInterval := 0;

  Available := GetClientBounds().Expand(-10);
  Degrees := FixD(Degrees);
  Remaining := Round(Self.GetCompassAngle() - Degrees);

  T := GetTickCount() + Round(SRL.TruncatedGauss(6000, 8000));

  while (Abs(Remaining) > Accuracy) do
  begin
    if (GetTickCount() > T) then
    begin
      Self.DebugLn('SetCompassAngle timed out');
      Exit;
    end;

    Pixels := Round(Abs(SRL.DeltaAngle(Self.GetCompassAngle(), Degrees)) * DEG_PER_PIXEL);
    LeftToRight := ((Remaining > 0) and (Abs(Remaining) <= 180)) or ((Remaining < 0) and (Abs(Remaining) > 180));

    MousePosition := CustomMouse.Position();

    if LeftToRight then
    begin
      if (not Available.Contains(MousePosition)) or ((MousePosition.Y + 200 > Available.Y2) or (MousePosition.X + Pixels > Available.X2)) then
      begin
        CustomMouse.Move([Available.X1, Available.Y1, Available.X1 + 200, Available.Y1 + 200]);

        MousePosition := CustomMouse.Position();
      end;

      Destination.X := MousePosition.X + Pixels;
      Destination.Y := Random(MousePosition.Y + 100, Available.Y2);
    end else
    begin
      if (not Available.Contains(MousePosition)) or ((MousePosition.Y + 200 > Available.Y2) or (MousePosition.X - Pixels < Available.X1)) then
      begin
        CustomMouse.Move([Available.X2 - 200, Available.Y1, Available.X2, Available.Y1 + 200]);

        MousePosition := CustomMouse.Position();
      end;

      Destination.X := MousePosition.X - Pixels;
      Destination.Y := Random(MousePosition.Y + 200, Available.Y2);
    end;

    CustomMouse.Hold(MOUSE_MIDDLE);
    CustomMouse.Move(Destination);
    CustomMouse.Release(MOUSE_MIDDLE);

    Wait(100, 1000, wdLeft);

    Remaining := Round(Self.GetCompassAngle() - Degrees);
  end;
end;

procedure TRSMinimap.Draw(Bitmap: TMufasaBitmap); override;
begin
  inherited;

  with Self.GetCompassCircle() do
    Bitmap.DrawCircle([X, Y], Radius, $00FFFF);
  with Self.GetXPCircle() do
    Bitmap.DrawCircle([X, Y], Radius, $00FFFF);
  with Self.GetHPCircle() do
    Bitmap.DrawCircle([X, Y], Radius, $00FFFF);
  with Self.GetPrayerCircle() do
    Bitmap.DrawCircle([X, Y], Radius, $00FFFF);
  with Self.GetRunCircle() do
    Bitmap.DrawCircle([X, Y], Radius, $00FFFF);
  with Self.GetSpecAttackCircle() do
    Bitmap.DrawCircle([X, Y], Radius, $00FFFF);

  Bitmap.DrawPoly(Self.GetPolygon(), $0000FF);
  Bitmap.DrawTPA(Self.GetPolygon(), $00FF00);
  Bitmap.SetPixel(Self.Center.X, Self.Center.Y, $0000FF);
end;

procedure TRSMinimap.Free;
begin
  FreeBitmap(Self.FlagBitmap);
end;

procedure TRSMinimap.Setup; override;
begin
  inherited;

  Self.Name := 'Minimap';
  Self.FlagBitmap := BitmapFromString(2, 2, 'meJxjYPgvaBzLEnYMSAIAFJIDYg==');

  AddOnTerminate(@Self.Free);
end;

procedure TRSMinimap.SetupAlignment(Mode: ERSClientMode); override;
begin
  inherited;

  case Self.Mode of
    ERSClientMode.RESIZABLE_CLASSIC, ERSClientMode.RESIZABLE_MODERN:
      begin
        Self.Alignment.Left := [@RootInterface.X2, -157];
        Self.Alignment.Right := [@RootInterface.X2, -6];
        Self.Alignment.Top := [@RootInterface.Y1, 8];
        Self.Alignment.Bottom := [@RootInterface.Y1, 159];

        Self.CompassCircleOffset := [-2, 14];
        Self.XPCircleOffset := [-50, 32];
        Self.HitpointsCircleOffset := [-13, 55];
        Self.PrayerCircleOffset := [-13, 90];
        Self.RunCircleOffset := [-3, 121];
        Self.SpecAttackCircleOffset := [19, 148];
        Self.PolygonOffset := [[0, -76], [21, -73], [40, -64], [56, -51], [68, -33], [75, -1], [68, 31], [50, 43], [40, 62], [21, 71], [0, 74], [-21, 71], [-40, 62], [-56, 49], [-68, 31], [-75, -1], [-68, -33], [-56, -51], [-40, -64], [-21, -73]];
      end;

    ERSClientMode.FIXED:
      begin
        Self.Alignment.Left := [@RootInterface.X2, -195];
        Self.Alignment.Right := [@RootInterface.X2,-50];
        Self.Alignment.Top := [@RootInterface.Y1, 8];
        Self.Alignment.Bottom := [@RootInterface.Y1, 159];

        Self.CompassCircleOffset := [-8, 12];
        Self.XPCircleOffset := [-50, 26];
        Self.HitpointsCircleOffset := [-13, 49];
        Self.PrayerCircleOffset := [-13, 84];
        Self.RunCircleOffset := [-3, 116];
        Self.SpecAttackCircleOffset := [19, 142];
        Self.PolygonOffset := [[21, -71], [39, -62], [55, -49], [67, -32], [70, 0], [66, 19], [57, 32], [41, 43], [20, 58], [12, 71], [0, 74], [-11, 72], [-24, 55], [-47, 39], [-60, 31], [-66, 22], [-71, 0], [-72, -14], [-67, -32], [-55, -49], [-39, -62], [-21, -71], [0, -74]];
      end;
  end;
end;

function TRSMinimap.IsPointOn(P: TPoint): Boolean; overload;
begin
  Result := SRL.PointInPoly(P, Self.GetPolygon());
end;

function TRSMinimap.IsPointOn(P: TPoint; Expand: Int32): Boolean; overload;
begin
  Result := SRL.PointInPoly(P, ExpandPolygon(Self.GetPolygon(), Expand));
end;

function TRSMinimap.IsPoisoned: Boolean;
begin
  Result := SRL.CountColor(CTS2(271525, 10, 0.05, 0.37), Self.GetHPCircle().Bounds) = 0;
end;

function TRSMinimap.CurePoison: Boolean;
var
  T: UInt64;
begin
  if Self.IsPoisoned() then
  begin
    Mouse.Click(Self.GetHPCircle(), MOUSE_LEFT);

    T := GetTickCount() + Round(SRL.TruncatedGauss(1000, 2000));
    while (T > GetTickCount()) do
    begin
      if not Self.IsPoisoned() then
        Exit(True);

      Wait(0, 1000, wdLeft);
    end;
  end;
end;



function TRSMinimap.IsRunEnabled: Boolean;
begin
  Result := SRL.CountColor(CTS2(4211520, 6, 2.84, 0.14), Self.GetRunCircle().Bounds) = 0;
end;

function TRSMinimap.EnableRun: Boolean;
var
  T: UInt64;
begin
  if not Self.IsRunEnabled() then
  begin
    Mouse.Click(Self.GetRunCircle(), MOUSE_LEFT);

    T := GetTickCount() + Round(SRL.TruncatedGauss(1000, 2000));
    while (T > GetTickCount()) do
    begin
      if Self.IsRunEnabled() then
        Exit(True);

      Wait(0, 1000, wdLeft);
    end;
  end;
end;

function TRSMinimap.DisableRun: Boolean;
var
  T: UInt64;
begin
  if Self.IsRunEnabled() then
  begin
    Mouse.Click(Self.GetRunCircle(), MOUSE_LEFT);

    T := GetTickCount() + Round(SRL.TruncatedGauss(1000, 2000));
    while (T > GetTickCount()) do
    begin
      if not Self.IsRunEnabled() then
        Exit(True);

      Wait(0, 1000, wdLeft);
    end;
  end;
end;

function TRSMinimap.FindFlag(out P: TPoint): Boolean;
begin
  Result := FindBitmapToleranceIn(Self.FlagBitmap, P.X, P.Y, Self.Bounds, 5);
end;

function TRSMinimap.HasFlag: Boolean; overload;
var
  P: TPoint;
begin
  Result := FindFlag(P);
end;

function TRSMinimap.HasFlag(WaitTime: Int32): Boolean; overload;
var
  P: TPoint;
  T: UInt64;
begin
  T := GetTickCount() + WaitTime;

  while (T > GetTickCount()) do
  begin
    if FindFlag(P) then
      Exit(True);

    Wait(0, 1000, wdLeft);
  end;
end;

procedure TRSMinimap.WaitFlag(UntilDistance: Int32 = 0);
var
  Current: TPoint;
  Previous: TPoint;
  Timeout: TCountDown;
begin
  Timeout.Init(Round(SRL.TruncatedGauss(4000, 6000)));

  while Self.FindFlag(Current) and (not Timeout.IsFinished()) do
  begin
    if Distance(Self.Center, Current) <= UntilDistance then
      Exit;

    if Current <> Previous then
    begin
      Previous := Current;

      Timeout.Restart();
    end;

    Wait(0, 1000, wdLeft);
  end;
end;


(*
Minimap.FindDotShadows
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.FindDotShadows(bmp: TMufasaBitmap): T2DPointArray;

Returns an ATPA of the found dot shadows in a bitmap of the minimap.

Example
-------

  bmp.FromClient(Minimap.Bounds());
  atpa := Minimap.FindDotShadows(bmp);
  bmp.DrawATPA(atpa);
  bmp.Debug();
  bmp.Free();
*)
function TRSMinimap.FindDotShadows(bmp: TMufasaBitmap): T2DPointArray;
const
  BLACK = 65536;
  SHADOW = 1;
  DOT_CENTER = 2;
  ICON = 3;
var
  matrix: T2DIntArray;
  bounds, center: TBox;

  function _GetColor(p: TPoint): Int32;
  begin
    if not bounds.Contains(p) then
      Exit(-2);

    //Set our matrix row if it's not set yet
    if matrix[p.Y] = [] then
    begin
      SetLength(matrix[p.Y], bmp.GetWidth());
      matrix[p.Y, p.X] := bmp.GetPixel(p.X, p.Y);
    end;

    //Since ints default to 0, we should actually read the pixel from the bitmap
    if matrix[p.Y, p.X] = 0 then
    begin
      matrix[p.Y, p.X] := bmp.GetPixel(p.X, p.Y);
      //Set it to -1 so we don't need to do this again.
      if matrix[p.Y, p.X] = 0 then
        matrix[p.Y, p.X] := -1;
    end;

    Result := matrix[p.Y, p.X];
  end;

  procedure _SetColor(p: TPoint; color: Int32);
  begin
    if matrix[p.Y] = [] then //if matrix row doesn't exist yet, create it.
      SetLength(matrix[p.Y], bmp.GetWidth());
    matrix[p.Y, p.X] := color; //set the color on our matrix
  end;

  procedure _SetColor(tpa: TPointArray; color: Int32); overload;
  var
    p: TPoint;
  begin
    for p in tpa do _SetColor(p, color);
  end;

  function _GetCandidates(p: TPoint): TPointArray; //Get dot shadow candidates for any given pixel
  const
    OFFSETS: TPointArray = [[1, 1], [2, 1], [-1, 1], [-2, 1], [-1, -1], [1,-1], [1, 0], [-1, 0], [-2, -1], [2, -1], [-3, 0], [3, 0]];
  var
    i: Int32;
    q: TPoint;
  begin
    for i := 0 to High(OFFSETS) do
    begin
      q := p.Offset(OFFSETS[i]);

      //Lower part of a dot shadow can only have a black pixel right below if it's an ICON
      //since it's hard to know if something was marked as ICON properly we better skip it too.
      if (i<4) then
        case _GetColor(q.Offset(0,1)) of
          BLACK, SHADOW, ICON: Continue;
        end;

      //DOT_CENTER is the center part of the minimap dots that will never ever have a black pixel.
      if _GetColor(q) <> DOT_CENTER then
        Result += q;
    end;
  end;

  function _GetDotCenter(p: TPoint): TPointArray; //Get the 4 central points of a dot shadow P coordinate
  begin
    p :=  p.Offset(1,-2);
    Result := [p, p.Offset(1,0), p.Offset(0,1), p.Offset(1,1)];
  end;

  function _CanBeShadow(p, q: TPoint): Boolean;
  begin
    case _GetColor(q) of
      BLACK, ICON: ;
      else if not center.Contains(q) then Exit;
    end;

    if p.DistanceTo(q) > 2 then
      Exit((_GetColor(p.Offset(1, 0)) <> BLACK) and (_GetColor(q.Offset(-1, 0)) <> BLACK));
    Result := _GetColor(q.Offset(0, -1)) <> BLACK;
  end;

  function _GetShadow(p: TPoint; out a, b, q: TPoint): Boolean;
  const
    OFFSETS: TPointArray = [[1, 0], [0, 2]];
  var
    i: Int32;
  begin
    q := p.Offset(3, 0);

    if not center.Contains(q) and (_GetColor(q) <> BLACK) then
      Exit;

    for i := 0 to High(OFFSETS) do
    begin
      a := p.Offset(OFFSETS[i]);
      if center.Contains(a) or (_GetColor(a) = BLACK) then
        Exit;
    end;

    a := p.Offset(1, 1);
    b := p.Offset(2, 1);
    _SetColor([p, a, b, q], 0);
    Result := True;
  end;

  function _DotOverlap(p: TPoint): Boolean;
  const
    OFFSETS: TPointArray = [[-3, 0], [-4, 0], [3, 0], [4, 0], [0, -3], [0, -4], [0, 3], [0, 4]];
  var
    i: Int32;
  begin
    for i := 0 to High(OFFSETS) do
      case _GetColor(p.Offset(OFFSETS[i])) of
        BLACK, SHADOW: Exit(True);
      end;
  end;

  procedure _CandidatesBounds(candidates: TPointArray; out lo, hi: TPoint);
  var
    i: Int32;
  begin
    lo := [$FFFFFF, $FFFFFF];
    hi := [0, 0];
    for i := 0 to High(candidates) do
    begin
      if candidates[i].X > hi.X then hi.X := candidates[i].X;
      if candidates[i].X < lo.X then lo.X := candidates[i].X;

      if candidates[i].Y > hi.Y then hi.Y := candidates[i].Y;
      if candidates[i].Y < lo.Y then lo.Y := candidates[i].Y;
    end;
  end;

  function _IsValidShadow(p, a, b, q: TPoint): Boolean;
  begin
    Result := (p.Y < a.Y) and (q.Y < b.Y) and (p.Y = q.Y) and (a.Y = b.Y) and
              (p.DistanceTo(a) = q.DistanceTo(b)) and (p.DistanceTo(b) = q.DistanceTo(a));
  end;

  function _GetPABQ(out p, a, b, q : TPoint; candidates: TPointArray; lo, hi: TPoint): Boolean;
  var
    i: Int32;
  begin
    a := [0,0];
    for i := 0 to 3 do
    begin
      if candidates[i].X = lo.X then
      begin
        p := candidates[i];
        Continue;
      end;

      if candidates[i].X = hi.X then
      begin
        q := candidates[i];
        Continue;
      end;

      if a = [0,0] then
        a := candidates[i]
      else
        b := candidates[i];
    end;

    if a.X > b.X then
      Swap(a, b);

    Result := _IsValidShadow(p, a, b, q);
  end;

  function _IsShadowUnder(out p, a, b, q : TPoint; candidates: TPointArray): Boolean;
  const
    OFFSETS: TPointArray = [[0, 2], [0, 3], [0, 4]];
  var
    i, j, iterations: Int32;
    lo, hi: TPoint;
    left, right: TPointArray;
  begin
    if Length(candidates) < 3 then
      Exit;

    candidates += p;
    iterations := High(candidates);

    if Length(candidates) = 13 then
    begin
      for i := 0 to iterations do
      begin
        for j := 0 to High(OFFSETS) do
          case _GetColor(candidates[i].Offset(OFFSETS[j])) of
            BLACK, ICON, SHADOW: Continue(2);
          end;

        Delete(candidates, i, 1);
        iterations := High(candidates);
        i -= 1;
      end;
    end;

    case Length(candidates) of
      0, 13: Exit;
    end;

    _CandidatesBounds(candidates, lo, hi);

    if Length(candidates) = 4 then
      Exit(_GetPABQ(p, a, b, q, candidates, lo, hi));

    for i := 0 to iterations do
    begin
      q := candidates[i];
      case q.Y of
        lo.Y: for a in [q.Offset(-3,0), q.Offset(3,0)] do
                if candidates.Find(a) > -1 then
                  Continue(2);

        hi.Y: if (q.X > lo.X) and (q.X < hi.X) then
                for a in [q.Offset(-1,0), q.Offset(1,0)] do
                  if not center.Contains(a) and (candidates.Find(a) > -1) then
                    for a in [q.Offset(-1,-1), q.Offset(1,-1)] do
                      if candidates.Find(a) > -1 then
                        Continue(3);
        else
        begin
          case q.X of
            lo.X: if candidates.Find(q.Offset(1,1)) > -1 then
                    Continue;
            hi.X: if candidates.Find(q.Offset(-1,1)) > -1 then
                    Continue;
            else Continue;
          end;
        end;
      end;

      Delete(candidates, i, 1);
      iterations := High(candidates);
      i := -1;
      _CandidatesBounds(candidates, lo, hi);
    end;

    if Length(candidates) = 4 then
      Exit(_GetPABQ(p, a, b, q, candidates, lo, hi));

    for i := 0 to iterations do
    begin
      q := candidates[i];

      if q.X < p.X then left += q
      else if q.X > p.X then right += q;
    end;

    //Decide on unreliable results.
    if (Length(left) = Length(right)) or (Length(candidates) > 6) then
    begin
      for i := 0 to High(left) do
        q := left[i];
        case _GetColor(q) of
          BLACK, SHADOW, ICON: Exit(_IsShadowUnder(p, a, b, q, left));
        end;

      for i := 0 to High(right) do
        q := right[i];
        case _GetColor(q) of
          BLACK, SHADOW, ICON: Exit(_IsShadowUnder(p, a, b, q, right));
        end;

      Exit;
    end;

    if Length(left) < 3 then
      Exit(_IsShadowUnder(p, a, b, q, right));
    if Length(right) < 3 then
      Exit(_IsShadowUnder(p, a, b, q, left));
  end;

  function _IsDotShadow(out p, a, b, q: TPoint): Boolean;
  var
    candidates, ab, pq: TPointArray;
    i, hi: Int32;
    pInAB, pInPQ: Boolean;
  begin
    candidates := _GetCandidates(p);
    hi := High(candidates);

    for i := 0 to hi do
    begin
      q := candidates[i];
      if not _CanBeShadow(p, q) or (_GetColor(q.Offset(0,-1)) = BLACK) or
         ((q.Y = p.Y) and (_GetColor(p.Offset(0,-1)) = BLACK)) then
      begin
        Delete(candidates, i, 1);
        hi := High(candidates);
        i -= 1;
        Continue;
      end;

      if q.Y < p.Y then
      begin
        if not pInAB then
        begin
          ab += p;
          pInAB := True;
        end;
        pq += q;
        Continue;
      end;

      if q.Y > p.Y then
      begin
        if not pInPQ then
        begin
          pq += p;
          pInPQ := True;
        end;
        ab += q;
        Continue;
      end;

      case q.DistanceTo(p) of
        1:  begin
              if not pInAB then
              begin
                ab += p;
                pInAB := True;
              end;
              ab += q;
            end;
        3:  begin
              if not pInPQ then
              begin
                pq += p;
                pInPQ := True;
              end;
              pq += q;
            end;
      end;
    end;

    if hi < 0 then
      Exit(_IsShadowUnder(p, a, b, q, _GetCandidates(p)));

    if Length(ab) = 1 then
    begin
      a := ab[0];
      if a.X = p.X then
        Exit;

      if a.X > p.X then
      begin
        if a.DistanceTo(p) < 2 then
          b := a.Offset(1,0)
        else
          b := a.Offset(-1,0);

        q := p.Offset(3, 0);
      end
      else
      begin
        if a.DistanceTo(p) < 2 then
          b := a.Offset(-1,0)
        else
          b := a.Offset(1,0);

        q := p.Offset(-3, 0);
      end;

      if not _DotOverlap(q) and not _DotOverlap(b) then
        Exit;

      if p.X > q.X then
        Swap(p, q);

      if a.X > b.X then
        Swap(a, b);

      Exit(_IsValidShadow(p, a, b, q));
    end;

    if Length(ab) = 2 then
    begin
      a := ab[0];
      b := ab[1];
      if a.X > b.X then
       Swap(a, b);

      p := a.Offset(-1,-1);
      q := p.Offset(3,0);

      Exit(_IsValidShadow(p, a, b, q));
    end;

    if Length(pq) = 1 then
    begin
      q := pq[0];

      if p.Y > q.Y then
      begin
        a := q;
        if a.X > p.X then
          q := p.Offset(3,0);
      end;

      if p.X > q.X then
        Swap(p, q);

      a := p.Offset(1,1);
      b := p.Offset(2,1);
      Exit(_IsValidShadow(p, a, b, q));
    end;

    Result := _IsShadowUnder(p, a, b, q, candidates);
  end;

  function _OnMinimap(p: TPoint): Boolean;
  begin
    if bounds.Contains(p) then
      Result := ((p.X > 6) or (p.Y < 103)) and ((p.X > 30) or (p.Y < 124));
  end;

  procedure _Delete(out tpa: TPointarray; out i, hi: Int32);
  begin
    Delete(tpa, i, 1);
    hi := High(tpa);
    i -= 1;
  end;

const
  ICON_OFFSETS: T2DPointArray = [[[0,-1],[0,1]], [[-1,0],[1,0]], [[-1,1],[1,-1]], [[0,-1],[-1,1]], [[0,1],[1,2]], [[-1,0],[-2,-1]]];
  ICON_OFFSETS_RECHECK: TPointArray = [[1,0],[2,0]];
var
  blacks, tpa: TPointArray;
  i, j, l, hi: Int32;
  counts: TIntegerArray;
  p, a, b, q: TPoint;
begin
  SetLength(matrix, bmp.getHeight());
  bounds := Box(4, 4, bmp.GetWidth() - 5, bmp.GetHeight() - 5);
  center := Box(bmp.getCenter(), 1, 1);
  if not bmp.FindColors(blacks, BLACK) then Exit;

  hi := High(blacks);

  for i := 0 to hi do //First loop to extract 100% sure dot shadows nd mark things in our matrix with educated guesses (ICON, SHADOW, DOT_CENTER)
  begin
    if i = -1 then Break;
    p := blacks[i];

    //Delete and skip indices that are not on the minimap (spec attack/run energy orbs)
    //Delete and skip indices that we marked on our matrix as ICON or SHADOW
    if not _OnMinimap(p) or (_GetColor(p) <> BLACK) then
    begin
      _Delete(blacks, i, hi);
      Continue;
    end;

    SetLength(counts, Length(ICON_OFFSETS));
    //Mark minimap icons (bank, water source, mining spot, etc) as ICON in our matrix
    for j := 0 to High(ICON_OFFSETS) do
    begin
      counts[j] := 0;
      tpa := [];
      for l := 0 to 1 do
      begin
        tpa += p.Offset(ICON_OFFSETS[j][l]); //done like this so we don't do offsets math needlessly
        case _GetColor(tpa[l]) of
          BLACK, ICON:
            if Inc(counts[j]) = 2 then
            begin
              _Delete(blacks, i, hi);
              matrix[p.Y, p.X] := ICON;
              matrix[tpa[0].Y, tpa[0].X] := ICON;
              matrix[tpa[1].Y, tpa[1].X] := ICON;
              Continue(3);
            end;
        end;
      end;
    end;

    //all pixels in a dot shadow never have this offset black
    for q in [[1,-1], [-1,-1]] do
      if _GetColor(p.Offset(q)) = BLACK then
      begin
        _Delete(blacks, i, hi);
        _SetColor(p, 0);
        Continue;
      end;

    if not _GetShadow(p, a, b, q) then
      Continue;

    //Mark known shadows as SHADOW in our matrix
    Result += [p, a, b, q];
    _SetColor([p, a, b, q], SHADOW);
    _SetColor(_GetDotCenter(p), DOT_CENTER);
  end;

  for i := 0 to hi do //Second loop to go through the remaining black pixels and process them
  begin
    p := blacks[i];
    l := 0;

    case _GetColor(p) of
      BLACK: ; //We continue through our code block...
      ICON:  //if pixel is ICON, we need to do a final check to be sure
        for j := 0 to 1 do
          case _GetColor(p.Offset(ICON_OFFSETS_RECHECK[j])) of
            BLACK, ICON:
              if Inc(l) = 2 then
              begin
                _Delete(blacks, i, hi);
                Continue(2);
              end;
          end;
      else
      begin
        _Delete(blacks, i, hi);
        Continue;
      end;
    end;

    if not _IsDotShadow(p, a, b, q) then
      Continue;

    Result += [p, a, b, q];
    _SetColor([p, a, b, q], SHADOW);
    _SetColor(_GetDotCenter(p), DOT_CENTER);

    Delete(blacks, i, 1);
    hi := High(blacks);
    i := -1;
  end;
end;

(*
Minimap.GetDotsBitmap
~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.GetDotsBitmap(BMP: TMufasaBitmap; Dots: ERSMinimapDots): TPointArray;

Returns the ERSMinimapDots found in a bitmap of the minimap.
*)
function TRSMinimap.GetDotsBitmap(bmp: TMufasaBitmap; dots: ERSMinimapDots): TPointArray;
const
  BLACK = 65536;
var
  blacks: T2DPointArray;

  function _IsDotColor(p: TPoint; color, t, minCount: Int32; limit: Int32 = 0): Boolean;
  const
    OFFSETS: TPointArray = [[1,0],[2,0],[0,1],[0,2],[1,1],[2,1],[3,1],[1,2],[2,2],[3,2],[1,3],[2,3]];
  var
    i: Int32;
    tmp: TPoint;
  begin
    if limit = 0 then
      limit := High(OFFSETS);

    for i := 0 to limit do
    begin
      tmp := p.Offset(OFFSETS[i]);
      if SimilarColors(color, bmp.GetPixel(tmp.X, tmp.Y), t) then
      begin
        //tmpBMP.SetPixel(tmp.X, tmp.Y, BLACK+1);
        if Dec(minCount) = 0 then
          Exit(True);
      end;
    end;
  end;

  function _FindDots(out blacks: T2DPointArray; color, t: Int32): TPointArray;
  var
    i, hi: Int32;
    c, topLeft: TPoint;
  begin
    c := bmp.GetCenter();
    hi := High(blacks);
    for i := 0 to hi do
    begin
      topLeft := blacks[i][0].Offset(0, -3);

      if topLeft.Offset(2, 2).DistanceTo(c) <= 2 then
      begin
        // match corner pixel colors instead to see what's under our character
        if _IsDotColor(topLeft, color, t, 4, 3) then
        begin
          Result += topLeft;
          Delete(blacks, i, 1);
          hi -= 1;
          i -= 1;
        end;

        //skip further center checks as they will lead to false positives.
        Continue;
      end;

      if _IsDotColor(topLeft, color, t, 8) then
      begin
        Result += topLeft;
        Delete(blacks, i, 1);
        hi -= 1;
        i -= 1;
      end;
    end;
  end;

const
  DOT_COLORS: TIntegerArray = [$FFFFFF, $00FFFF, $0000FF];
var
  dot: ERSMinimapDot;
begin
  try
    blacks := Self.FindDotShadows(bmp);
    SetColorToleranceSpeed(2);

    for dot in dots do
    begin
      case dot of
        ERSMinimapDot.PLAYER: SetToleranceSpeed2Modifiers(0.001, 0.001);
        ERSMinimapDot.NPC: SetToleranceSpeed2Modifiers(0.05, 1);
        ERSMinimapDot.ITEM: SetToleranceSpeed2Modifiers(0.05, 1);
      end;
      Result += _FindDots(blacks, DOT_COLORS[Ord(dot)], 25);
    end;
  finally
    SetColorToleranceSpeed(1);
    SetToleranceSpeed2Modifiers(0.2, 0.2);
  end;
end;

(*
Minimap.GetDots
~~~~~~~~~~~~~~~
.. pascal::
  function TRSMinimap.GetDots(Dots: ERSMinimapDots): TPointArray;
  function TRSMinimap.GetDots(Dot: ERSMinimapDot): TPointArray; overload;

Returns a TPointArray with the coordinates of the ERSMinimapDots found on the minimap.
*)
function TRSMinimap.GetDots(dots: ERSMinimapDots): TPointArray;
var
  bmp: TMufasaBitmap;
begin
  bmp.FromClient(Self.Bounds());

  Result := Self.GetDotsBitmap(bmp, dots);
  Result := Result.Offset([Self.X1, Self.Y1]);

  bmp.Free();
end;

function TRSMinimap.GetDots(dot: ERSMinimapDot): TPointArray; overload;
begin
  Result := Self.GetDots([dot]);
end;



function TRSMinimap.IsPlayerMoving(MinShift: Integer = 500): Boolean;
begin
  with Self.Center do
    Result := SRL.GetPixelShift([X - 40, Y - 40, X + 40, Y + 40], 300) >= MinShift;
end;

procedure TRSMinimap.WaitPlayerMoving(MinShift: Integer = 500; Timeout: Int32 = 20000);
var
  T: UInt64;
begin
  T := GetTickCount + TimeOut;
  while (T > GetTickCount()) and Self.IsPlayerMoving(MinShift) do
    ;
end;

function TRSMinimap.GetHPLevel: Int32;
begin
  Result := Self.GetOrbLevel(Self.GetHPCircle());
end;

function TRSMinimap.GetHPPercent: Int32;
var
  TPA: TPointArray;
  Circle: TCircle;
begin
  Circle := Self.GetHPCircle();
  if SRL.FindColors(TPA, CTS1(1250067, 20), Circle.Bounds) > 0 then
    TPA := TPA.FilterDist(0, Circle.Radius, Circle.X, Circle.Y);

  with TPA.Bounds() do
    Result := 100 - Ceil((Y2 - Y1) / (Circle.Bounds.Y2 - Circle.Bounds.Y1) * 100);
end;

var
  Minimap: TRSMinimap;

procedure TRSClient.ClientModeChanged; override;
begin
  inherited;

  Minimap.SetupAlignment(Self.Mode);
end;

procedure TSRL.Setup; override;
begin
  inherited;

  Minimap.Setup();
end;

procedure TSRL.Debug(Bitmap: TMufasaBitmap); override;
begin
  inherited;

  Minimap.Draw(Bitmap);
end;
