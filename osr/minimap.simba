{$DEFINE SRL_MINIMAP_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

type
  ERSMinimapDot = (
    PLAYER, 
    NPC, 
    ITEM
  );
  ERSMinimapDots = set of ERSMinimapDot;

type
  TRSMinimap = record(TRSInterface)
    CompassCircleOffset:    array[ERSClientMode] of TPoint;
    XPCircleOffset:         array[ERSClientMode] of TPoint;
    HitpointsCircleOffset:  array[ERSClientMode] of TPoint;
    PrayerCircleOffset:     array[ERSClientMode] of TPoint;
    RunCircleOffset:        array[ERSClientMode] of TPoint;
    SpecAttackCircleOffset: array[ERSClientMode] of TPoint;
    PolygonOffset:          array[ERSClientMode] of TPointArray;
  end;

function TRSMinimap.GetCompassCircle: TCircle;
begin
  with Self.CompassCircleOffset[RSClient.ClientMode] do
    Result := [Self.X1 + X, Self.Y1 + Y, 17];
end;

function TRSMinimap.GetXPCircle: TCircle;
begin
  with Self.XPCircleOffset[RSClient.ClientMode] do
    Result := [Self.X1 + X + 10, Self.Y1 + Y, 11];
end;

function TRSMinimap.GetHPCircle: TCircle;
begin
  with Self.HitpointsCircleOffset[RSClient.ClientMode] do
    Result := [Self.X1 + X, Self.Y1 + Y, 12];
end;

function TRSMinimap.GetPrayerCircle: TCircle;
begin
  with Self.PrayerCircleOffset[RSClient.ClientMode] do
    Result := [Self.X1 + X, Self.Y1 + Y, 12];
end;

function TRSMinimap.GetRunCircle: TCircle;
begin
  with Self.RunCircleOffset[RSClient.ClientMode] do
    Result := [Self.X1 + X, Self.Y1 + Y, 12];
end;

function TRSMinimap.GetSpecAttackCircle: TCircle;
begin
  with Self.SpecAttackCircleOffset[RSClient.ClientMode] do
    Result := [Self.X1 + X, Self.Y1 + Y, 12];
end;

function TRSMinimap.GetOrbLevel(Orb: TCircle): Int32;
begin
  Result := OCR.RecognizeNumber([Orb.X-35, Orb.Y-1, Orb.X-15, Orb.Y+9], TOCRShadowFilter.Create(), RS_FONT_PLAIN_11);
end;

function TRSMinimap.GetRunEnergy: Int32;
begin
  Result := Self.GetOrbLevel(GetRunCircle());
end;

function TRSMinimap.GetPolygon: TPointArray;
begin
  Result := Self.PolygonOffset[RSClient.ClientMode].Offset(Self.Center);
end;

type
  TRSCompassDials = record
    N, S, E, W: TPoint;
  end;

function TRSMinimap.FindCompassDials: TRSCompassDials;

  function FindDialColor(Center: TPoint; Radius: Integer; Color: TCTS1Color): TPointArray;
  var
    B: TBox;
  begin
    B.X1 := Center.X - Radius;
    B.Y1 := Center.Y - Radius;
    B.X2 := Center.X + Radius;
    B.Y2 := Center.Y + Radius;

    if SRL.FindColors(Result, Color, B) > 0 then
      Result := Result.ExcludeDist(Center, 0, Radius);
  end;

var
  ATPA: T2DPointArray;
  TPA: TPointArray;
  North: TPointArray;
begin
  with GetCompassCircle() do
  begin
    // find red on compass
    TPA := FindDialColor(Mean(), Radius, CTS1(2565532, 50));
    ATPA := TPA.Split(5);

    if (Length(ATPA) <> 4) then
    begin
      Self.DebugLn('GetCompassAngle: Red dials not found');
      Exit;
    end;

    // remove center red arrow (always the biggest)
    ATPA.SortBySize(False);
    ATPA.Pop();

    // find north (brown) dial
    North := FindDialColor(Mean(), Radius, CTS1(1911089, 25));

    if (Length(North) = 0) then
    begin
      Self.DebugLn('GetCompassAngle: North dial not found');
      Exit;
    end;

    // South dial is always furthest from north dial
    TPA := ATPA.Middles();
    TPA.Sort(North.Middle);

    Result.N := North.Middle();
    Result.S := TPA.Pop();

    // figure out what is east/west dials
    Result.E := TPA[0];
    Result.W := TPA[1];

    if (AngleBetween(Result.N, Result.S) >= 180) then
    begin
      if (Result.E.Y > Result.W.Y) then Swap(Result.E, Result.W);
    end else
    begin
      if (Result.W.Y > Result.E.Y) then Swap(Result.E, Result.W);
    end;
  end;
end;

function TRSMinimap.GetCompassAngle(AsDegrees: Boolean = True): Double;
var
  TPA: TPointArray;
  I: Integer;
  Dials: TRSCompassDials;
  Angles: TExtendedArray;
begin
  // Find center dial
  with GetCompassCircle() do
    SRL.FindColors(TPA,  CTS1(15857142, 25), TBox.Create(X-3, Y-3, X+3, Y+3));

  if (Length(TPA) = 0) then
  begin
    Self.DebugLn('GetCompassAngle: Center not found');
    Exit;
  end;

  Dials := Self.FindCompassDials();

  for I := 0 to High(TPA) do
  begin
    Angles += [
      ArcTan2(Dials.E.Y - TPA[I].Y, Dials.E.X - TPA[I].X),
      ArcTan2(Dials.S.Y - TPA[I].Y, Dials.S.X - TPA[I].X) - (PI / 2),
      ArcTan2(Dials.W.Y - TPA[I].Y, Dials.W.X - TPA[I].X) - (PI)
    ];
  end;

  for I := 0 to High(Angles) do
  begin
    if (Angles[I] <> 0) then
      Angles[I] := Angles[I] + 0.0333; //compass dial is floored.. this makes us more accurate.

    Angles[I] := FixD(Degrees(Angles[I]));
  end;

  Result := Average(Angles);
  if not AsDegrees then
    Result := Radians(Result);
end;

procedure TRSMinimap.SetCompassAngle(Degrees: Double; Accuracy: Double = 5);
const
  DEG_PER_PIXEL = 2.83;
var
  Available: TBox;
  Remaining: Int32;
  LeftToRight: Boolean;
  Destination: TPoint;
  MousePosition: TPoint;
  Pixels: Int32;
  T: UInt64;
  CustomMouse: TMouse;
begin
  CustomMouse := Mouse;
  CustomMouse.MissChance := 0;
  CustomMouse.IdleInterval := 0;

  Available := GetClientBounds().Expand(-10);
  Degrees := FixD(Degrees);
  Remaining := Round(Self.GetCompassAngle() - Degrees);

  T := GetTickCount() + Round(SRL.TruncatedGauss(6000, 8000));

  while (Abs(Remaining) > Accuracy) do
  begin
    if (GetTickCount() > T) then
    begin
      Self.DebugLn('SetCompassAngle timed out');
      Exit;
    end;

    Pixels := Round(Abs(DeltaAngle(Self.GetCompassAngle(), Degrees)) * DEG_PER_PIXEL);
    LeftToRight := ((Remaining > 0) and (Abs(Remaining) <= 180)) or ((Remaining < 0) and (Abs(Remaining) > 180));

    MousePosition := CustomMouse.Position();

    if LeftToRight then
    begin
      if (not Available.Contains(MousePosition)) or ((MousePosition.Y + 200 > Available.Y2) or (MousePosition.X + Pixels > Available.X2)) then
      begin
        CustomMouse.Move([Available.X1, Available.Y1, Available.X1 + 200, Available.Y1 + 200]);

        MousePosition := CustomMouse.Position();
      end;

      Destination.X := MousePosition.X + Pixels;
      Destination.Y := Random(MousePosition.Y + 100, Available.Y2);
    end else
    begin
      if (not Available.Contains(MousePosition)) or ((MousePosition.Y + 200 > Available.Y2) or (MousePosition.X - Pixels < Available.X1)) then
      begin
        CustomMouse.Move([Available.X2 - 200, Available.Y1, Available.X2, Available.Y1 + 200]);

        MousePosition := CustomMouse.Position();
      end;

      Destination.X := MousePosition.X - Pixels;
      Destination.Y := Random(MousePosition.Y + 200, Available.Y2);
    end;

    CustomMouse.Hold(MOUSE_MIDDLE);
    CustomMouse.Move(Destination);
    CustomMouse.Release(MOUSE_MIDDLE);

    Wait(100, 1000, wdLeft);

    Remaining := Round(Self.GetCompassAngle() - Degrees);
  end;
end;

procedure TRSMinimap.Draw(Bitmap: TMufasaBitmap); override;
begin
  inherited;

  with Self.GetCompassCircle() do
    Bitmap.DrawCircle([X, Y], Radius, $00FFFF);
  with Self.GetXPCircle() do
    Bitmap.DrawCircle([X, Y], Radius, $00FFFF);
  with Self.GetHPCircle() do
    Bitmap.DrawCircle([X, Y], Radius, $00FFFF);
  with Self.GetPrayerCircle() do
    Bitmap.DrawCircle([X, Y], Radius, $00FFFF);
  with Self.GetRunCircle() do
    Bitmap.DrawCircle([X, Y], Radius, $00FFFF);
  with Self.GetSpecAttackCircle() do
    Bitmap.DrawCircle([X, Y], Radius, $00FFFF);

  Bitmap.DrawPolygon(Self.GetPolygon(), $0000FF);
  Bitmap.DrawTPA(Self.GetPolygon(), $00FF00);
  Bitmap.SetPixel(Self.Center.X, Self.Center.Y, $0000FF);
end;

procedure TRSMinimap.Setup(Name: String); override;
begin
  inherited;

  with Self.BoundsFinder.Alignments[ERSClientMode.FIXED] do
  begin
    Left   := [@RootInterface.X2, -195];
    Right  := [@RootInterface.X2,-50];
    Top    := [@RootInterface.Y1, 8];
    Bottom := [@RootInterface.Y1, 159];
  end;

  with Self.BoundsFinder.Alignments[ERSClientMode.RESIZABLE_CLASSIC] do
  begin
    Left   := [@RootInterface.X2, -157];
    Right  := [@RootInterface.X2, -6];
    Top    := [@RootInterface.Y1, 8];
    Bottom := [@RootInterface.Y1, 159];
  end;

  with Self.BoundsFinder.Alignments[ERSClientMode.RESIZABLE_MODERN] do
  begin
    Left   := [@RootInterface.X2, -157];
    Right  := [@RootInterface.X2, -6];
    Top    := [@RootInterface.Y1, 8];
    Bottom := [@RootInterface.Y1, 159];
  end;

  Self.CompassCircleOffset[ERSClientMode.FIXED]    := [-8, 12];
  Self.XPCircleOffset[ERSClientMode.FIXED]         := [-50, 26];
  Self.HitpointsCircleOffset[ERSClientMode.FIXED]  := [-13, 49];
  Self.PrayerCircleOffset[ERSClientMode.FIXED]     := [-13, 84];
  Self.RunCircleOffset[ERSClientMode.FIXED]        := [-3, 116];
  Self.SpecAttackCircleOffset[ERSClientMode.FIXED] := [19, 142];
  Self.PolygonOffset[ERSClientMode.FIXED]          := [[21, -71], [39, -62], [55, -49], [67, -32], [70, 0], [66, 19], [57, 32], [41, 43], [20, 58], [12, 71], [0, 74], [-11, 72], [-24, 55], [-47, 39], [-60, 31], [-66, 22], [-71, 0], [-72, -14], [-67, -32], [-55, -49], [-39, -62], [-21, -71], [0, -74]];

  Self.CompassCircleOffset[ERSClientMode.RESIZABLE_MODERN]    := [-2, 14];
  Self.XPCircleOffset[ERSClientMode.RESIZABLE_MODERN]         := [-50, 32];
  Self.HitpointsCircleOffset[ERSClientMode.RESIZABLE_MODERN]  := [-13, 55];
  Self.PrayerCircleOffset[ERSClientMode.RESIZABLE_MODERN]     := [-13, 90];
  Self.RunCircleOffset[ERSClientMode.RESIZABLE_MODERN]        := [-3, 121];
  Self.SpecAttackCircleOffset[ERSClientMode.RESIZABLE_MODERN] := [19, 148];
  Self.PolygonOffset[ERSClientMode.RESIZABLE_MODERN]          := [[0, -76], [21, -73], [40, -64], [56, -51], [68, -33], [75, -1], [68, 31], [50, 43], [40, 62], [21, 71], [0, 74], [-21, 71], [-40, 62], [-56, 49], [-68, 31], [-75, -1], [-68, -33], [-56, -51], [-40, -64], [-21, -73]];

  // Same as above
  Self.CompassCircleOffset[ERSClientMode.RESIZABLE_CLASSIC]    := [-2, 14];
  Self.XPCircleOffset[ERSClientMode.RESIZABLE_CLASSIC]         := [-50, 32];
  Self.HitpointsCircleOffset[ERSClientMode.RESIZABLE_CLASSIC]  := [-13, 55];
  Self.PrayerCircleOffset[ERSClientMode.RESIZABLE_CLASSIC]     := [-13, 90];
  Self.RunCircleOffset[ERSClientMode.RESIZABLE_CLASSIC]        := [-3, 121];
  Self.SpecAttackCircleOffset[ERSClientMode.RESIZABLE_CLASSIC] := [19, 148];
  Self.PolygonOffset[ERSClientMode.RESIZABLE_CLASSIC]          := [[0, -76], [21, -73], [40, -64], [56, -51], [68, -33], [75, -1], [68, 31], [50, 43], [40, 62], [21, 71], [0, 74], [-21, 71], [-40, 62], [-56, 49], [-68, 31], [-75, -1], [-68, -33], [-56, -51], [-40, -64], [-21, -73]];
end;

function TRSMinimap.IsPointOn(P: TPoint): Boolean; overload;
begin
  Result := PointInPolygon(P, Self.GetPolygon());
end;

function TRSMinimap.IsPointOn(P: TPoint; Expand: Int32): Boolean; overload;
begin
  Result := PointInPolygon(P, ExpandPolygon(Self.GetPolygon(), Expand));
end;

function TRSMinimap.IsPoisoned: Boolean;
begin
  Result := SRL.CountColor(CTS2(271525, 10, 0.05, 0.37), Self.GetHPCircle().Bounds) = 0;
end;

function TRSMinimap.CurePoison: Boolean;
var
  T: UInt64;
begin
  if Self.IsPoisoned() then
  begin
    Mouse.Click(Self.GetHPCircle(), MOUSE_LEFT);

    T := GetTickCount() + Round(SRL.TruncatedGauss(1000, 2000));
    while (T > GetTickCount()) do
    begin
      if not Self.IsPoisoned() then
        Exit(True);

      Wait(0, 1000, wdLeft);
    end;
  end;
end;



function TRSMinimap.IsRunEnabled: Boolean;
begin
  Result := SRL.CountColor(CTS2(4211520, 6, 2.84, 0.14), Self.GetRunCircle().Bounds) = 0;
end;

function TRSMinimap.EnableRun: Boolean;
var
  T: UInt64;
begin
  if not Self.IsRunEnabled() then
  begin
    Mouse.Click(Self.GetRunCircle(), MOUSE_LEFT);

    T := GetTickCount() + Round(SRL.TruncatedGauss(1000, 2000));
    while (T > GetTickCount()) do
    begin
      if Self.IsRunEnabled() then
        Exit(True);

      Wait(0, 1000, wdLeft);
    end;
  end;
end;

function TRSMinimap.DisableRun: Boolean;
var
  T: UInt64;
begin
  if Self.IsRunEnabled() then
  begin
    Mouse.Click(Self.GetRunCircle(), MOUSE_LEFT);

    T := GetTickCount() + Round(SRL.TruncatedGauss(1000, 2000));
    while (T > GetTickCount()) do
    begin
      if not Self.IsRunEnabled() then
        Exit(True);

      Wait(0, 1000, wdLeft);
    end;
  end;
end;

function TRSMinimap.FindFlag(out P: TPoint): Boolean;
begin
  Result := FindBitmapToleranceIn(RSBitmaps.MinimapFlag.GetIndex(), P.X, P.Y, Self.Bounds, 5);
end;

function TRSMinimap.HasFlag: Boolean; overload;
var
  P: TPoint;
begin
  Result := FindFlag(P);
end;

function TRSMinimap.HasFlag(WaitTime: Int32): Boolean; overload;
var
  P: TPoint;
  T: UInt64;
begin
  T := GetTickCount() + WaitTime;

  while (T > GetTickCount()) do
  begin
    if FindFlag(P) then
      Exit(True);

    Wait(0, 1000, wdLeft);
  end;
end;

procedure TRSMinimap.WaitFlag(UntilDistance: Int32 = 0);
var
  Current: TPoint;
  Previous: TPoint;
  Timeout: TCountDown;
begin
  Timeout.Init(Round(SRL.TruncatedGauss(4000, 6000)));

  while Self.FindFlag(Current) and (not Timeout.IsFinished()) do
  begin
    if Distance(Self.Center, Current) <= UntilDistance then
      Exit;

    if Current <> Previous then
    begin
      Previous := Current;

      Timeout.Restart();
    end;

    Wait(0, 1000, wdLeft);
  end;
end;

function TRSMinimap.GetDotsBitmap(BMP: TMufasaBitmap; Dots: ERSMinimapDots): TPointArray;
var
  Blacks: TPointArray;

  // Lots if indexing here! It's safe so we can disable rangechecks.
  {$rangechecks off}
  function FindDots(Color, Tolerance: Int32; Hue, Sat: Extended): TPointArray;
  var
    i: Int32;
    p: TPoint;
    left, right: Boolean;
    mat: TIntegerMatrix;
    TPA: TPointArray;
    sum: Integer;
  begin
    bmp.FindColorsTolerance(TPA, Color, Tolerance, Hue, Sat);
    if Length(TPA) < 8 then
      Exit;

    mat.SetSize(BMP.GetWidth(), BMP.GetHeight());
    mat.SetValues(TPA, 1);

    for i:=0 to High(Blacks)-1 do
    begin
      left := ((BMP.GetPixel(Blacks[i].x+3,Blacks[i].y+0) = 65536) and (BMP.GetPixel(Blacks[i].x+1,Blacks[i].y-1) <> 65536)) or
              ((BMP.GetPixel(Blacks[i].x+2,Blacks[i].y+1) = 65536) and (BMP.GetPixel(Blacks[i].x+1,Blacks[i].y+0) <> 65536));

      right := False;
      if not left then
        right := ((BMP.GetPixel(Blacks[i].x-2,Blacks[i].y+1) = 65536) and (BMP.GetPixel(Blacks[i].x-1,Blacks[i].y+0) <> 65536));

      if left or right then
      begin
        p := Blacks[i];
        if right then p.x -= 3;
        p.y -= 3;

        sum := 0;
        sum += mat[p.y+0, p.x+1];
        sum += mat[p.y+0, p.x+2];
        sum += mat[p.y+1, p.x+0];
        sum += mat[p.y+1, p.x+1];
        sum += mat[p.y+1, p.x+2];
        sum += mat[p.y+1, p.x+3];
        sum += mat[p.y+2, p.x+0];
        sum += mat[p.y+2, p.x+1];
        sum += mat[p.y+2, p.x+2];
        sum += mat[p.y+2, p.x+3];
        sum += mat[p.y+3, p.x+1];
        sum += mat[p.y+3, p.x+2];

        if (Sum >= 8) then
          Result += p;
      end;
    end;
  end;
  {$rangechecks on}

begin
  BMP.FindColors(Blacks, 65536);

  if Length(Blacks) > 0 then
  begin
    Blacks := Blacks.ExcludeBox(TBox.Create(4, 4, BMP.GetWidth() - 4, BMP.GetHeight() - 4));

    if (ERSMinimapDot.PLAYER in Dots) then
      Result += FindDots($FFFFFF, 30, 0.001, 0.001);
    if (ERSMinimapDot.NPC in Dots) then
      Result += FindDots($00FFFF, 30, 0.05, 1);
    if (ERSMinimapDot.ITEM in Dots) then
      Result += FindDots($0000FF, 30, 0.05, 1);

    Result := Result.Unique();
  end;
end;

function TRSMinimap.GetDots(Dots: ERSMinimapDots): TPointArray; overload;
var
  BMP: TMufasaBitmap;
begin
  BMP.Init();
  BMP.LoadFromClient(Self.Bounds());

  Result := GetDotsBitmap(BMP, Dots);
  Result := Result.Offset([Self.X1, Self.Y1]);

  BMP.Free();
end;

function TRSMinimap.GetDots(Dot: ERSMinimapDot): TPointArray; overload;
begin
  Result := GetDots([Dot]);
end;

function TRSMinimap.IsPlayerMoving(MinShift: Integer = 500): Boolean;
begin
  with Self.Center do
    Result := SRL.GetPixelShift([X - 40, Y - 40, X + 40, Y + 40], 300) >= MinShift;
end;

procedure TRSMinimap.WaitPlayerMoving(MinShift: Integer = 500; Timeout: Int32 = 20000);
var
  T: UInt64;
begin
  T := GetTickCount + TimeOut;
  while (T > GetTickCount()) and Self.IsPlayerMoving(MinShift) do
    ;
end;

function TRSMinimap.GetHPLevel: Int32;
begin
  Result := Self.GetOrbLevel(Self.GetHPCircle());
end;

function TRSMinimap.GetHPPercent: Int32;
var
  TPA: TPointArray;
  Circle: TCircle;
begin
  Circle := Self.GetHPCircle();
  if SRL.FindColors(TPA, CTS1(1250067, 20), Circle.Bounds) > 0 then
    TPA := TPA.ExcludeDist(Circle.Mean, 0, Circle.Radius);

  with TPA.Bounds() do
    Result := 100 - Ceil((Y2 - Y1) / (Circle.Bounds.Y2 - Circle.Bounds.Y1) * 100);
end;

var
  Minimap: TRSMinimap;

begin
  Minimap.Setup('Minimap');
end;
