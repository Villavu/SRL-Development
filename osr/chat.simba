(*
Chat
====
Methods to interact with the chat box.
*)

{$DEFINE SRL_CHAT_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

const
  CHAT_COLOR_BLACK        = $000000; 
  CHAT_COLOR_MAROON       = $7F0000; 
  CHAT_COLOR_BLUE         = $FF0000; 
  CHAT_COLOR_PURPLE       = $7F007F; 
  CHAT_COLOR_RED          = $2010EF;
  CHAT_COLOR_LIGHT_RED    = $0000FF;
  CHAT_COLOR_WHITE        = $FFFFFF; 
  CHAT_COLOR_LIGHT_PURPLE = $FF9090; 
  CHAT_COLOR_NAVY         = $800000;  
  
  CHAT_MESSAGE_COLORS: TIntegerArray = [
    CHAT_COLOR_BLACK,
    CHAT_COLOR_MAROON,
    CHAT_COLOR_BLUE,
    CHAT_COLOR_PURPLE,
    CHAT_COLOR_RED,
    CHAT_COLOR_LIGHT_RED,
    CHAT_COLOR_WHITE,
    CHAT_COLOR_LIGHT_PURPLE
  ];

const
  CHAT_MESSAGE_LINES = [0..7];
  CHAT_INPUT_LINE = 8;

type
  TRSChat = type TRSInterface;
  

(*
Chat.Setup
~~~~~~~~~~
.. pascal:: procedure TRSChat.Setup; override;

Initializes **Chat** variables.

.. note:: This is automatically called on the **Chat** variable.
*)
procedure TRSChat.Setup; override;
begin
  inherited;

  Self.Name := 'Chatbox';
end;

(*
Chat.SetupAlignment
~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TRSChat.SetupAlignment(Mode: ERSClientMode); override;

Setups up the interface aligment for the current client mode.

.. note:: This is automatically called on the **TRSClient.ClientModeChanged** function.
*)
procedure TRSChat.SetupAlignment(Mode: ERSClientMode); override;
begin
  inherited;

  Self.Alignment.Left := [@ChatButtons.X1];
  Self.Alignment.Right := [@ChatButtons.X2];
  Self.Alignment.Top := [@ChatButtons.Y1, -142];
  Self.Alignment.Bottom := [@ChatButtons.Y1, -1];
end;

procedure TRSChat.Draw(Bitmap: TMufasaBitmap); override;
begin
  if not Self.IsOpen() then
    Exit;

  inherited;

  Bitmap.DrawBoxes(Self.GetLineBoxes(), $00FFFF);
end;

(*
Chat.GetLineBoxes
~~~~~~~~~~~~~~~~~
.. pascal:: function TRSChat.GetLineBoxes: TBoxArray;

Internal function that returns the bounds of the chat lines.
*)
function TRSChat.GetLineBoxes: TBoxArray;
begin
  Result := Grid(1, 9, Width - 35, 13, [0, 1], [Self.X1 + 10, Self.Y1 + 8]);
  Result[CHAT_INPUT_LINE].Y2 += 2;
end;

(*
Chat.GetDisplayName
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSChat.GetDisplayName(Colors: TIntegerArray = [$FFFFFF, $000000]): String;

Get the user displayed name.

Example
-------

  WriteLn('The user name is: ', Chat.GetDisplayName);
*)
function TRSChat.GetDisplayName(Colors: TIntegerArray = [$FFFFFF, $000000]): String;
var
  Color: Int32;
begin
  for Color in Colors do
  begin
    Result := OCR.RecognizeStatic(Self.GetLineBoxes()[CHAT_INPUT_LINE], TOCRColorRule.Create([Color]), RS_FONT_PLAIN_12);
    if Result <> '' then
      Break;
  end;

  if ':' in Result then
    Result := Result.Before(':');
end;

(*
Chat.IsTransparent
~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSChat.IsTransparent: Boolean;

Returns true if the chat box is in transparent mode.

Example
-------

  WriteLn Chat.IsTransparent;
*)
function TRSChat.IsTransparent: Boolean;
begin
  Result := Self.GetDisplayName([$FFFFFF]) <> '';
end;

(*
Chat.IsOpen
~~~~~~~~~~~
.. pascal:: function TRSChat.IsOpen: Boolean;

Returns true if the chat box is open.

Example
-------

  WriteLn Chat.IsOpen;
*)
function TRSChat.IsOpen: Boolean;
begin
  Result := (SRL.CountColor(CTS0(9744834, 20), Self.Bounds) > 45000) or Self.IsTransparent();
end;


(*
Chat.GetQuery
~~~~~~~~~~~~~
.. pascal:: function TRSChat.GetQuery: String;

Returns the query question.

Example
-------

  WriteLn Chat.GetQuery;
*)
function TRSChat.GetQuery: String;
begin
  Result := OCR.Recognize(Self.Bounds(), TOCRColorRule.Create([$000000]), RS_FONT_BOLD_12);
end;

(*
Chat.GetQueryAnswer
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSChat.GetQueryAnswer: String;

Returns the currently typed answer.

Example
-------

  WriteLn Chat.GetQueryAnswer;
*)
function TRSChat.GetQueryAnswer: String;
begin
  Result := OCR.Recognize(Self.Bounds(), TOCRColorRule.Create([8388608]), RS_FONT_BOLD_12);
end;

(*
Chat.FindQuery
~~~~~~~~~~~~~~
.. pascal:: function TRSChat.FindQuery(Query: String; WaitTime: Int32; Interval: Int32 = -1): Boolean;

Returns true if the specified **Query** is currently open or opens up within **WaitTime**.

Example
-------

  WriteLn Chat.FindQuery('How many doses', 2000); //Example query of NMZ Potion Barrels.
*)
function TRSChat.FindQuery(Query: String; WaitTime: Int32; Interval: Int32 = -1): Boolean;
begin
  if Interval = -1 then
    Interval := SRL.TruncatedGauss(50, 1500);

  Result := WaitUntil(Query in Self.GetQuery(), Interval, WaitTime);
end;

(*
Chat.AnswerQuery
~~~~~~~~~~~~~~~~
.. pascal:: function TRSChat.AnswerQuery(Query, Answer: String; WaitTime: Int32; Interval: Int32 = -1): Boolean;

Replies with **Answer** to the specified **Query**.

Example
-------

  Chat.AnswerQuery('How many doses', '20', 2000); //Example query of NMZ Potion Barrels.
*)
function TRSChat.AnswerQuery(Query, Answer: String; WaitTime: Int32; Interval: Int32 = -1): Boolean;
begin
  if Result := FindQuery(Query, WaitTime, Interval) then
  begin
    if Self.GetQueryAnswer() <> Answer then
      while Self.GetQueryAnswer() <> '*' do
        Keyboard.PressKey(VK_BACK);
  
    Keyboard.Send(Answer, VK_ENTER);
  end;
end;

type
  TRSChatboxOption = record
    Text: String;
    Bounds: TBox;
    Number: Int32;
  end;
  TRSChatboxOptionArray = array of TRSChatboxOption;

(*
Chat.GetOptions
~~~~~~~~~~~~~~~
.. pascal:: function TRSChat.GetOptions(Colors: TIntegerArray = [CHAT_COLOR_BLACK, CHAT_COLOR_WHITE]): TRSChatboxOptionArray;

Internal function to retrieve the currently available chat options.
*)
function TRSChat.GetOptions(Colors: TIntegerArray = [CHAT_COLOR_BLACK, CHAT_COLOR_WHITE]): TRSChatboxOptionArray; 
var
  Strings: TStringArray;
  Boxes: TBoxArray;
  I, Key: Int32;
begin
  Strings := OCR.RecognizeMulti(Self.Bounds(), TOCRColorRule.Create(Colors), RS_FONT_QUILL_8, Boxes);

  SetLength(Result, Length(Strings));
  for I := 0 to High(Result) do
  begin
    if ('Click here to continue' in Strings[I]) then
      Key := VK_SPACE
    else
      Key := VK_1 + I;
      
    Result[I] := [Strings[I], Boxes[I], Key];
  end;
end;

(*
Chat.FindOption
~~~~~~~~~~~~~~~
.. pascal:: function TRSChat.FindOption(Text: String; Colors: TIntegerArray = [CHAT_COLOR_WHITE, CHAT_COLOR_BLUE]): Boolean;

Returns true if the specified **Text** is an available option.

Example
-------

  Chat.FindOption('Yes'); //Common chat option in several instances as an example where you are asked Yes or No.
*)
function TRSChat.FindOption(Text: String; Colors: TIntegerArray = [CHAT_COLOR_WHITE, CHAT_COLOR_BLUE]): Boolean;
var
  Option: TRSChatboxOption;
begin
  for Option in GetOptions(Colors) do
    if Text in Option.Text then
      Exit(True);
end;

(*
Chat.ClickOption
~~~~~~~~~~~~~~~~
.. pascal:: function TRSChat.ClickOption(Text: String; UseKeyboard: Boolean = True; Colors: TIntegerArray = [CHAT_COLOR_BLACK, CHAT_COLOR_WHITE]): Boolean;

Attempts to click the specied chat option. If **UseKeyboard** is true, the keyboard will be used.

Example
-------

  Chat.ClickOption('Yes', True); //Common chat option in several instances as an example where you are asked Yes or No.
*)
function TRSChat.ClickOption(Text: String; UseKeyboard: Boolean = True; Colors: TIntegerArray = [CHAT_COLOR_BLACK, CHAT_COLOR_WHITE]): Boolean;
var
  Option: TRSChatboxOption;
begin
  for Option in GetOptions(Colors) do
    if Text in Option.Text then
    begin 
      if UseKeyboard then
        Keyboard.PressKey(Option.Number)
      else
        Mouse.Click(Option.Bounds, MOUSE_LEFT);

      Exit(True);
    end;
end;

(*
Chat.ClickContinue
~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSChat.ClickContinue(UseKeyboard: Boolean = True): Boolean;

Attempts to click the continue chat option. If **UseKeyboard** is true, the keyboard will be used.

Example
-------

  Chat.ClickContinue(True);
*)
function TRSChat.ClickContinue(UseKeyboard: Boolean = True): Boolean;
begin
  if Self.ClickOption('Click here to continue', UseKeyboard, [CHAT_COLOR_BLUE, CHAT_COLOR_WHITE]) then
  begin
    Result := WaitUntil(Self.FindOption('Please wait', [CHAT_COLOR_BLUE, CHAT_COLOR_WHITE]), SRL.TruncatedGauss(50, 1500), 3000) and
              WaitUntil(not Self.FindOption('Please wait', [CHAT_COLOR_BLUE, CHAT_COLOR_WHITE]), SRL.TruncatedGauss(50, 1500), 3000);
  end;
end;

(*
Chat.ChatToOption
~~~~~~~~~~~~~~~~~
.. pascal:: function TRSChat.ChatToOption(Option: String): Boolean;

Continuously advances the chat with **TRSChat.ClickContinue** until the specified **Option** appears.

Example
-------

  Chat.ChatToOption('Yes');
*)
function TRSChat.ChatToOption(Option: String): Boolean;
var
  Timeout: TCountdown;
begin
  Timeout.Init(10000);
  while (not Timeout.IsFinished) and (not Self.FindOption(Option)) and Self.ClickContinue() do
    Wait(0, 2500, wdLeft);

  Result := Self.ClickOption(Option);
end;

(*
Chat.GetMessage
~~~~~~~~~~~~~~~
.. pascal:: function TRSChat.GetMessage(Line: Int32; Colors: TIntegerArray = CHAT_MESSAGE_COLORS): String;

Get the message in the specified **Line**.

Example
-------

  WriteLn Chat.GetMessage(5);
*)
function TRSChat.GetMessage(Line: Int32; Colors: TIntegerArray = CHAT_MESSAGE_COLORS): String; 
const
  StaticOffset = 2; // Make static text placement so RecognizeStatic can be used
var
  B: TBox;
  X: Int32;
  Transparent: Boolean;
  Matrix: T2DIntegerArray;
begin
  B := GetLineBoxes()[Line];
  B.Y1 -= StaticOffset; 
  
  Transparent := Self.IsTransparent();
  if Transparent then
    Colors.Remove(CHAT_COLOR_BLACK, True);
  
  if (Length(Colors) > 0) then
  begin
    Matrix := GetColorsMatrix(B.X1, B.Y1, B.X2, B.Y2);
    
    // Shadow from above line draws over our line.
    // Mark the shadow as a match since OCR requires 100% character match.
    if Transparent then
      for X := 0 to High(Matrix[StaticOffset]) do
        if (Matrix[StaticOffset][X] = CHAT_COLOR_BLACK) theN
          Matrix[StaticOffset][X] := Colors[0];
  
    Result := OCR.RecognizeStatic(Matrix, TOCRColorRule.Create(Colors), RS_FONT_PLAIN_12);
  end;
end;

(*
Chat.FindMessage
~~~~~~~~~~~~~~~~
.. pascal:: function TRSChat.FindMessage(Message: String; Colors: TIntegerArray = CHAT_MESSAGE_COLORS): Boolean;

Returns true if **Message** is found in any chat line.

Example
-------

  WriteLn Chat.FindMessage('Buying gf');
*)
function TRSChat.FindMessage(Message: String; Colors: TIntegerArray = CHAT_MESSAGE_COLORS): Boolean;
var
  I: Int32;
begin
  for I := 0 to CHAT_INPUT_LINE - 1 do
    if Message in Self.GetMessage(I, Colors) then
      Exit(True);    
end;

(*
Chat.GetChat
~~~~~~~~~~~~
.. pascal:: function TRSChat.GetChat: String;

Returns the message displayed in a chat when we are talking with an NPC or interacting with something.

Example
-------

  WriteLn Chat.GetChat;
*)
function TRSChat.GetChat: String;
var
  Option: TRSChatboxOption;
begin
  for Option in Self.GetOptions() do
  begin
    if Result <> '' then
      Result += LineEnding;
      
    Result += Option.Text;
  end;
end;

(*
Chat.GetChatTitle
~~~~~~~~~~~~~~~~~
.. pascal:: function TRSChat.GetChatTitle: String;

Returns the chat title if available. This is usually a red text and sometimes has 2 swords pointing to it.

Example
-------

  if 'Select an Option' = Chat.GetChatTitle then
    Chat.ClickOption('access my bank');
*)
function TRSChat.GetChatTitle: String;
var
  Options: TRSChatboxOptionArray;
begin
  Options := Self.GetOptions([$000080]);
  if Length(Options) > 0 then
    Result := Options[0].Text;
end;

(*
Chat.LeveledUp
~~~~~~~~~~~~~~
.. pascal:: function TRSChat.LeveledUp: Boolean;

Returns true if we have the level up message on the chat box.

Example
-------

  if Chat.LeveledUp then
    Chat.ClickContinue(True);
*)
function TRSChat.LeveledUp: Boolean;
begin
  Result := Self.FindOption('Congratulations', [CHAT_COLOR_NAVY]); 
end;

(*
var Chat
~~~~~~~~
  Global Chat variable.
*)
var
  Chat: TRSChat;

procedure TRSClient.ClientModeChanged; override;
begin
  inherited;

  Chat.SetupAlignment(Self.Mode);
end;

procedure TSRL.Setup; override;
begin
  inherited;

  Chat.Setup();
end;

procedure TSRL.Debug(Bitmap: TMufasaBitmap); override;
begin
  inherited;

  Chat.Draw(Bitmap);
end;
