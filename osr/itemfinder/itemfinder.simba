(*
Item Finder
===========
*)

{$DEFINE SRL_ITEMFINDER_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

const
  ITEM_FINDER_IMAGES_VERSION = '3'; // Inc if images have changed
  ITEM_FINDER_IMAGES_ZIP     = {$macro CURRENT_DIRECTORY} + '/item-images.zip';
  ITEM_FINDER_IMAGES_PATH    = {$macro CURRENT_DIRECTORY} + '/images/' + ITEM_FINDER_IMAGES_VERSION + '/';

  ITEM_FINDER_ITEM_NAMES_FILE  = {$macro CURRENT_DIRECTORY} + '/item-names';

type
  TRSItem = Variant;
  TRSItemArray = array of TRSItem;

  TRSItemFinderCustomFilter = procedure(Image, Templ: TMufasaBitmap) of object;

  TRSItemFinder = record(TSRLBaseRecord)
    ItemNames: TStringList;
    ItemFilters: array of record
      Name: String;
      Filter: TRSItemFinderCustomFilter;
    end;

    ItemImages: array of record
      Name: String;
      Images: array of TMufasaBitmap;
    end;

    Similarity: Single;
  end;

procedure TRSItemFinder.Free;
var
  I, J: Int32;
begin
  Self.ItemNames.Free();

  for I := 0 to High(Self.ItemImages) do
    for J := 0 to High(Self.ItemImages[I].Images) do
      Self.ItemImages[I].Images[J].Free();
end;

procedure TRSItemFinder.Setup;
var
  Filter: TRSItemFinderCustomFilter;
begin
  ForceDirectories(ITEM_FINDER_IMAGES_PATH);

  Self.Name := 'Item Finder';
  Self.Similarity := 0.999;

  Self.ItemNames.Init();
  Self.ItemNames.LoadFromFile(ITEM_FINDER_ITEM_NAMES_FILE);
  Self.ItemNames.SetSorted(True);

  AddOnTerminate(@Self.Free);
end;

procedure TRSItemFinder.AddItemName(Item, ID: String);
begin
  Self.ItemNames.Add(Item + '=' + ID);
end;

procedure TRSItemFinder.AddItemFilter(Item: String; Filter: TRSItemFinderCustomFilter);
begin
  Self.ItemFilters += [Item, @Filter];
end;

function TRSItemFinder.GetItemIDs(Item: String): TIntegerArray;
var
  ItemID: Int32;
begin
  if Item.IsNumber() then
    Result := Result + Item.ExtractNumber()
  else
  begin
    ItemID := Self.ItemNames.IndexOfName(Item);
    if ItemID = -1 then
      Exit;

    while SameText(Item, Self.ItemNames.GetNames(ItemID)) do
    begin
      Result := Result + StrToInt(Self.ItemNames.GetValueFromIndex(ItemID));

      Inc(ItemID);
    end;
  end;
end;

function TRSItemFinder.GetItemImages(Item: String): array of TMufasaBitmap;
var
  FileName: String;
  Image: TMufasaBitmap;
  ItemID: Int32;
  I, J: Int32;
begin
  for I := 0 to High(Self.ItemImages) do
    if (Self.ItemImages[I].Name = Item) then
    begin
      Result := Self.ItemImages[I].Images;

      Exit;
    end;

  for ItemID in GetItemIDs(Item) do
  begin
    FileName := ExpandFileName(ITEM_FINDER_IMAGES_PATH + ToStr(ItemID) + '.png');

    if FileExists(FileName) or UnZipOneFile(ITEM_FINDER_IMAGES_ZIP, ExtractFileName(FileName), ITEM_FINDER_IMAGES_PATH) then
    begin
      Image.Init();
      Image.LoadFromFile(FileName);
      Image.SetName(Item);
      Image.ReplaceColor(RSColors.ITEM_SHADOW, 0);

      for J := 0 to High(Result) do
        if Image.Equals(Result[J]) then
        begin
          Image.Free();
          Image := nil;

          Break;
        end;

      if (Image <> nil) then
        Result += Image;
    end else
      Self.Fatal('Unknown item: ' + ToStr(ItemID));
  end;

  if (Length(Result) = 0) then
    Self.Fatal('Unknown item: ' + Item);

  Self.ItemImages += [Item, Result];
end;

procedure TRSItemFinder.ClearSparkles(Image, Templ: TMufasaBitmap);
var
  I: Int32;
  ImagePtr, TemplPtr: PRGB32;
begin
  ImagePtr := Image.GetData();
  TemplPtr := Templ.GetData();
  
  for I := 0 to (Image.GetWidth() * Image.GetHeight())-1 do
  begin
    // grey/brightness calculation. Works for magic logs
    if ((ImagePtr^.R + ImagePtr^.G + ImagePtr^.B) div 3 > 130) or    
       ((TemplPtr^.R + TemplPtr^.G + TemplPtr^.B) div 3 > 130) then
      ImagePtr^ := TemplPtr^ := Default(TRGB32);
    
    Inc(ImagePtr);
    Inc(TemplPtr);
  end;
end;

function TRSItemFinder.CompareItems(Image, Template: TMufasaBitmap; CustomFilter: TRSItemFinderCustomFilter=nil): Single;
var
  ImageBorder, TemplateBorder: TPointArray;
  TPA, ClearTPA: TPointArray;
  AlignedTemplate, AlignedImage: TMufasaBitmap;
  Align: TPoint;
  ClearColor: Int32;
  P: TPoint;
begin
  if Image.FindColors(ImageBorder, RSColors.ITEM_BORDER) and Template.FindColors(TemplateBorder, RSColors.ITEM_BORDER) then
  begin
    with TemplateBorder.Bounds() do
    begin
      Template.Crop(X1, Y1, X2, Y2);
      TemplateBorder := TemplateBorder.Offset(-X1,-Y1);
    end;
    
    // Use highest Y point of both images for alignment
    // TPA is already sorted like this with how FindColors operates.
    Align.X := Max(0, ImageBorder[High(ImageBorder)].X - TemplateBorder[High(TemplateBorder)].X);
    Align.Y := Max(0, ImageBorder[High(ImageBorder)].Y - TemplateBorder[High(TemplateBorder)].Y);
  
    // Compare borders. Sparkles can modify boundaries.
    if (@CustomFilter = nil) then
      for P in TemplateBorder.Offset(Align) do
      begin
        if (P.Y <= 8) then // Possible stack number... Don't compare.
          Continue;
        if not Contains(P, ImageBorder) then // Borders don't match. No point going further.
          Exit;
      end;
    
    AlignedImage := Image.Copy();
  
    AlignedTemplate.Init();
    AlignedTemplate.SetSize(Image.GetWidth(), Image.GetHeight());

    AlignedTemplate.DrawBitmap(Template, Align);

    if (@CustomFilter <> nil) then
      ClearSparkles(AlignedImage, AlignedTemplate);

    // Clear these template colors on both images
    for ClearColor in [RSColors.ITEM_TEXT_YELLOW, RSColors.ITEM_TEXT_WHITE, RSColors.ITEM_TEXT_GREEN, RSColors.ITEM_BORDER] do
      if AlignedTemplate.FindColors(TPA, ClearColor) then 
        ClearTPA += TPA;  
   
    // Clear image background on template
    if AlignedImage.FindColors(TPA, 0) then 
      ClearTPA += TPA;  

    AlignedTemplate.DrawTPA(ClearTPA, 0);
    AlignedImage.DrawTPA(ClearTPA, 0);

    Result := AlignedImage.MatchTemplate(AlignedTemplate, TM_CCORR_NORMED)[0][0]; // IDK why I used CCORR. But it works!
  
    AlignedImage.Free();
    AlignedTemplate.Free(); 
  end;
end;

type
  TRSItemFinderMatch = record
    Item: TRSItem;
    Box: TBox;
    Index: Integer;
  end;
  TRSItemFinderMatchArray = array of TRSItemFinderMatch;

function TRSItemFinder.FindAll(Items: TRSItemArray; Boxes: TBoxArray; MaxToFind: Integer = 0): TRSItemFinderMatchArray;
var
  I, J: Integer;
  Images: TMufasaBitmapArray;
  Template: TMufasaBitmap;
  Filter: TRSItemFinderCustomFilter;
  ItemsToSearchFor: array of record
    Image: TMufasaBitmap;
    Name: TRSItem;
    Filter: TRSItemFinderCustomFilter;
  end;
begin
  for I := 0 to High(Items) do
  begin
    Filter := nil;
    for J := 0 to High(ItemFilters) do
      if SameText(ItemFilters[J].Name, Items[I]) then
        Filter := @ItemFilters[J].Filter;

    Images := Self.GetItemImages(Items[I]);
    for J := 0 to High(Images) do
      ItemsToSearchFor += [Images[J], Items[I], @Filter];
  end;

  SetLength(Images, Length(Boxes));
  for I := 0 to High(Images) do
  begin
    Images[I].Init();
    Images[I].LoadFromClient(Boxes[I]);
  end;

  try
    for I := 0 to High(Images) do
      for J := 0 to High(ItemsToSearchFor) do
      begin
        Template := Images[I].Copy();

        try
          // Search for item image *ON* the screen image since screen image is never larger than 36x36 item image.
          if Self.CompareItems(ItemsToSearchFor[J].Image, Template, @ItemsToSearchFor[J].Filter) >= Self.Similarity then
          begin
            Result += [ItemsToSearchFor[J].Name, Boxes[I], I];
            if Length(Result) = MaxToFind then
              Exit;
          end;
        finally
          Template.Free();
        end;
      end;
  finally
    for I := 0 to High(Images) do
      Images[I].Free();
  end;
end;

function TRSItemFinder.Find(Items: TRSItemArray; Boxes: TBoxArray; out Match: TRSItemFinderMatch): Boolean;
var
  Matches: TRSItemFinderMatchArray;
begin
  Matches := Self.FindAll(Items, Boxes, 1);

  Result := Length(Matches) = 1;
  if Result then
    Match := Matches[0];
end;

var
  ItemFinder: TRSItemFinder;

begin
  ItemFinder.Setup();

  // Special filters
  ItemFinder.AddItemFilter('magic logs', @ItemFinder.ClearSparkles);
  ItemFinder.AddItemFilter('noted magic logs', @ItemFinder.ClearSparkles);
  ItemFinder.AddItemFilter('1513', @ItemFinder.ClearSparkles);
  ItemFinder.AddItemFilter('1514', @ItemFinder.ClearSparkles);

  // We can map some useful things here
  //ItemFinder.AddItemName('Arrow shaft', '300');
end;
