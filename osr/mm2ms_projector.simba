{$DEFINE SRL_MM2MS_PROJECTOR_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

type
  TMM2MSProjector = record
  class const
    FIXED_Y_LOOK = -25.5;
    FIXED_SCALE_MIN = 0.80;
    FIXED_SCALE_MAX = 6.32;

    RESIZABLE_Y_LOOK = -21;
    RESIZABLE_SCALE_MIN = 0.635;
    RESIZABLE_SCALE_MAX = 4.90;
  class var
    ZOOM_VALUES: array[0..100] of Single;
  var
    ZoomLevel: Integer;
  end;

function TMM2MSProjector.Run(Coords: Vector3Array; Rotation: Vector3): TPointArray; overload;
var
  Zoom: Single;
  Scale: Single;
  ViewMatrix, ProjMatrix, WorldMatrix, TransMatrix: TMatrix4;
  MainScreenMiddle: TPoint;
  MainScreenHeight: Integer;

  function Transform(Coord: Vector3; Matrix: TMatrix4): Vector3;
  var
    P: Vector3;
  begin
    P := Vector3.TransformCoordinate(Coord, Matrix);
    Result.X := (+P.X * 513 * Scale) + MainScreenMiddle.X;
    Result.Y := (-P.Y * 335 * Scale) + MainScreenMiddle.Y + (Zoom * 24); // y shift
  end;

var
  I: Int32;
  ScaleMin, ScaleMax: Single;
begin
  Zoom := ZOOM_VALUES[Self.ZoomLevel];

  MainScreenMiddle := MainScreen.Center;
  MainScreenHeight := MainScreen.Height;

  case RSClient.ClientMode of
    ERSClientMode.FIXED:
      begin
        ScaleMin := Self.FIXED_SCALE_MIN * MainScreenHeight / 503;
        ScaleMax := Self.FIXED_SCALE_MAX * MainScreenHeight / 503;
        Scale := ScaleMin + Zoom * (ScaleMax - ScaleMin);

        ViewMatrix := TMatrix4.LookAtRH([0, Self.FIXED_Y_LOOK, 61], [0, 0, 1.3], Vector3_UnitY);
        ProjMatrix := TMatrix4.PerspectiveFovRH(Sqrt(2), 765 / 503, 0.01, 1.0);
        WorldMatrix := TMatrix4.RotationYawPitchRoll(Rotation.Y, Rotation.X, Rotation.Z) * Matrix_Identity;
        TransMatrix := WorldMatrix * ViewMatrix * ProjMatrix;
      end;

    ERSClientMode.RESIZABLE_MODERN, ERSClientMode.RESIZABLE_CLASSIC:
      begin
        ScaleMin := Self.RESIZABLE_SCALE_MIN * MainScreenHeight / 503;
        ScaleMax := Self.RESIZABLE_SCALE_MAX * MainScreenHeight / 503;
        Scale := ScaleMin + Zoom * (ScaleMax - ScaleMin);

        ViewMatrix := TMatrix4.LookAtRH([0, Self.RESIZABLE_Y_LOOK, 61], [0, 0, 1.3], Vector3_UnitY);
        ProjMatrix := TMatrix4.PerspectiveFovRH(Sqrt(2), 765 / 503, 0.01, 1.0);
        WorldMatrix := TMatrix4.RotationYawPitchRoll(Rotation.Y, Rotation.X, Rotation.Z) * Matrix_Identity;
        TransMatrix := WorldMatrix * ViewMatrix * ProjMatrix;
      end;
  end;

  SetLength(Result, Length(Coords));

  for I := 0 to High(Coords) do
    with Transform(Coords[I], TransMatrix) do
    begin
      Result[I].X := Round(X);
      Result[I].Y := Round(Y);
    end;
end;

function TMM2MSProjector.Run(Coord: Vector3; Rotation: Vector3): TPoint; overload;
begin
  Result := Run([Coord], Rotation)[0];
end;

// OSRS zooms at a non standard value (for this projector)
// This curve figures it out (credit: slacky)
// Best solution is to adjust the projector to work at this curve without so much WTF.
function TMM2MSProjector.GetZoomValue(level: Integer): Single; static;
var
  x,y,p: Single;
begin
  y := 1 - (Ln(100-level+2.5)-Ln(2.5)) / (Ln(100+2.5)-Ln(2.5));
  x := 1 - (Ln(100-level/1.32)-Ln(100-100/1.32)) / (Ln(100)-Ln(100-100/1.32));
  p := level/100;
  Result := x * (p) + y * (1-p);
end;

procedure TMM2MSProjector.BuildZoomValues; static;
var
  I: Integer;
begin
  for I := 0 to 100 do
    ZOOM_VALUES[I] := GetZoomValue(I);
end;

begin
  TMM2MSProjector.BuildZoomValues();
end;
