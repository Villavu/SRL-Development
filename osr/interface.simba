{$DEFINE SRL_INTERFACE_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

{$i interface_boundsfinder.simba}
{$i interface_elementfinder.simba}
{$i interface_itemfinder.simba}

type
  TRSInterface = record(TSRLBaseRecord)
    BoundsFinder: TRSInterfaceBoundsFinder;
    ElementFinder: TRSInterfaceElementFinder;
    ItemFinder: TRSInterfaceItemFinder;

    Elements: TRSInterfaceElementArray;
  end;

procedure TRSInterface.Setup(Name: String);
begin
  Self.Name := Name;
  Self.ElementFinder.GetBoundsFunction := @BoundsFinder.Find;
end;

function TRSInterface.Bounds: TBox;
begin
  Result := Self.BoundsFinder.Find(RSClient.ClientMode);
end;

function TRSInterface.X1: Int32;
begin
  Result := Bounds.X1;
end;

function TRSInterface.X2: Int32;
begin
  Result := Bounds.X2;
end;

function TRSInterface.Y1: Int32;
begin
  Result := Bounds.Y1;
end;

function TRSInterface.Y2: Int32;
begin
  Result := Bounds.Y2;
end;

function TRSInterface.Width: Int32; 
begin
  Result := Bounds.Width;
end;

function TRSInterface.Height: Int32; 
begin
  Result := Bounds.Height;
end;

function TRSInterface.Center: TPoint; 
begin
  Result := Self.Bounds().Middle;
end;

type
  TRSScrollBar = record
    SliderRegion: TBox;
    Slider: TBox;
    Position: Int32;
  end;
  
procedure TRSScrollBar.Draw(Bitmap: TMufasaBitmap); constref;
begin
  Bitmap.DrawBox(Self.SliderRegion, $00FFFF);
  Bitmap.DrawBox(Self.Slider, $00FFFF);
  Bitmap.SetFontAntialiasing(False);
  Bitmap.SetFontSize(20);
  with Bitmap.TextSize(ToString(Self.Position)) do
    Bitmap.DrawText(ToString(Self.Position), [Self.SliderRegion.Middle.X - (X div 2), Self.Slider.Middle.Y - (Y div 3)], $00FF00);
end;

function TRSScrollBar.IsVisible: Boolean;
begin
  Result := Self <> [];
end;

function TRSInterface.GetScrollBar: TRSScrollBar;
const
  COLOR_ARROW := CTS2(5206147, 15, 0.03, 0.28);
  COLOR_BORDER := 65536;
var
  TPA: TPointArray;
  Arrows: TBoxArray;
  Area, B: TBox;
begin
  Area := Self.Bounds();
  
  if SRL.FindColors(TPA, COLOR_ARROW, Area) > 0 then
  begin
    for B in TPA.Cluster(1).Bounds() do
      if (B.Width = 14) and (B.Height = 14) and (SRL.CountColor(COLOR_BORDER, B.Expand(1, Area)) = 62) then
        Arrows += B;
        
    Arrows.SortByX(False);   
    
    if (Length(Arrows) >= 2) and (Arrows[0].X1 = Arrows[1].X1) and (Arrows[1].X2 = Arrows[1].X2) then
    begin
      if (Arrows[0].Y1 > Arrows[1].Y1) then
        Swap(Arrows[0], Arrows[1]);
        
      B.X1 := Arrows[0].X1;
      B.Y1 := Arrows[0].Y2 + 2;
      B.X2 := Arrows[1].X2;
      B.Y2 := Arrows[1].Y1 - 2;
  
      if SRL.FindColors(TPA, COLOR_BORDER, B) > 0 then 
      begin
        Result.SliderRegion := B;
        Result.Slider := TPA.Bounds;
        Result.Position := Round((Result.Slider.Y1 - Result.SliderRegion.Y1) * 100 / (Result.SliderRegion.Height - Result.Slider.Height));
      end;
    end; 
  end;
end;

function TRSInterface.CanScroll: Boolean;
var
  ScrollBar: TRSScrollBar := Self.GetScrollBar();
begin
  Result := Scrollbar.IsVisible() and (ScrollBar.Slider <> ScrollBar.SliderRegion);
end;

function TRSInterface.GetScrollPosition: Int32;
var
  ScrollBar: TRSScrollBar;
begin
  Result := -1;
  
  ScrollBar := Self.GetScrollBar();
  if ScrollBar.IsVisible() then
    Result := ScrollBar.Position;
end;

procedure TRSInterface.SetScrollPosition(Value: Int32);
var
  ScrollBar: TRSScrollBar;
begin
  Value := EnsureRange(Value, 0, 100);

  ScrollBar := Self.GetScrollBar();
  
  if ScrollBar.IsVisible() then
  begin
    if (ScrollBar.Position < Value) then 
    begin 
      while ScrollBar.IsVisible() and (ScrollBar.Position < Value) do
      begin
        Mouse.Scroll(ScrollBar.SliderRegion, Random(1, 3), True);
        
        ScrollBar := Self.GetScrollBar();
      end;
    end else
    if (ScrollBar.Position > Value) then 
    begin
      while ScrollBar.IsVisible() and (ScrollBar.Position > Value) do
      begin
        Mouse.Scroll(ScrollBar.SliderRegion, Random(1, 3), False);
        
        ScrollBar := Self.GetScrollBar();
      end;
    end;
  end;
end;

procedure TRSInterface.Draw(Bitmap: TMufasaBitmap);
var
  ScrollBar: TRSScrollBar;
  I: Integer;
begin
  Bitmap.DrawBox(Self.Bounds(), $00FFFF);

  for I:=0 to High(Self.Elements) do
    Bitmap.DrawBox(Self.ElementFinder.Bounds(Self.Elements[I]), $00FF00);

  ScrollBar := Self.GetScrollBar();
  if ScrollBar.IsVisible() then
    ScrollBar.Draw(Bitmap);
end;

function TRSInterface.ClickCloseButton: Boolean;
var
  B: TBox;
  X, Y: Integer;
begin
  // Top right corner
  B := Self.Bounds;
  B.X1 := B.X2 - 50;
  B.Y2 := B.Y1 + 50;

  if FindBitmapToleranceIn(RSBitmaps.CloseInterfaceButton.GetIndex(), X, Y, B, 45) then
  begin
    Mouse.Click(TBox.Create(X, Y, X + RSBitmaps.CloseInterfaceButton.GetWidth(), Y + RSBitmaps.CloseInterfaceButton.GetHeight()), MOUSE_LEFT);

    Result := True;
    Exit;
  end;
end;

function TRSInterface.IsTitle(Text: String; MinMatch: Single = 0.80): Boolean;
var
  B: TBox;
begin
  B := Self.Bounds();
  B.X1 += 70;
  B.Y1 += 10;
  B.X2 -= 70;
  B.Y2 := B.Y1 + 15;
  B.Clip(Self.Bounds);

  Result := OCR.LocateText(B, Text, RS_FONT_BOLD_12, TOCRInvertColorFilter.Create([3358536, 0], [5, 0]), B) > MinMatch;
end;

type
  TRSRootInterface = type TRSInterface;

function TRSRootInterface.CustomBoundsFinder(ClientMode: ERSClientMode): TBox;
var
  W, H: Integer;
begin
  GetClientDimensions(W, H);

  Result.X1 := 0;
  Result.Y1 := 0;
  Result.X2 := W-1;
  Result.Y2 := H-1;
end;

procedure TRSRootInterface.Setup(Name: String); override;
begin
  inherited;

  Self.BoundsFinder.CustomFunction := @Self.CustomBoundsFinder;
end;

var
  RootInterface: TRSRootInterface;

begin
  RootInterface.Setup('Root Interface');
end;
